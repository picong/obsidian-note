## 编排系统如何快速调整出错的服务？
控制回路：根据当前状态与期望状态的差距，控制器对集群进行调节控制，就能让集群当前状态逐渐接近期望状态。、
![[Pasted image 20240524094947.png]]
如果用户想使用这些资源(计算资源、安全、服务、令牌、网络等功能的资源)，如果用户想使用这些资源来实现某种需求，并不能像平常编程那样，去调用某个或某一组方法来达成目的。而是要通过描述清楚这些资源的期望状态，有Kubernetes中对应监视这些资源的控制器，来驱动资源的实际状态向期望状态靠拢，才能够达成自己的目的。

而这种交互风格就被叫做 `Kubernetes 的声明式API`，元数据文件中的spec字段所描述的就是资源的期望状态。
> **Kubernetes 的资源对象与控制器**
> 下面根据用途分类，列举了一些常见的资源：
> - 用于描述如何创建、销毁、更新、扩缩Pod，包括：Autoscaling(HPA)、CronJob、DaemonSet、Deployment、Job、Pod、ReplicaSet、StatefulSet
> - 用于配置信息的设置与更新，包括：ConfigMap、Secret
> - 用户持久性地存储文件或者Pod之间的文件共享，包括：Volume、LocalVolume、PersistentVolume、PersistentVolumeClaim、StorageClass
> - 用于维护网络通信和服务访问的安全，包括：SecurityContext、ServiceAccount、Endpoint、NetworkPolicy
> - 用于定义服务与访问，包括：Ingress、Service、EndpointSlice
> - 用户划分虚拟集群、节点和资源配额，包括：Namespace、Node、ResourceQuata
> 这些资源在控制器管理框架下，一般都会有相应的控制器来管理，这里我也列举了一些常见的控制器，按照它们的启动情况进行了分类，如下：
> - 必须启动的控制器：EndpointController、ReplicationController、PodGCController、ResourceQuotaController、NamespaceController、ServiceAccountController、GarbageCollectorController、DaemonSetController、JobController、DeploymentController、ReplicaSetController、HPAController、DisruptionController、StatefulSetController、CronJobController、CSRSigningController、CSRApprovingController、TTLController
> - 默认启用的可选控制器，可通过选项禁用：TokenController、NodeController、ServiceController、RouteController、PVBinderController、AttachDetachController
> - 默认禁止的可选控制器，可通过选项启用：BootstrapSignerController、TokencleanerController

那么，与资源相对应的，只要是实际状态有可能发生变化的资源对象，就通常会 **由对应的控制器进行追踪，每个控制器至少会追踪一种类型资源。**
Kubernetes设计了统一的控制器管理框架(kuber-controller-manager)来维护控制器的正常工作，并设计了统一的指标监视器(kuber-apiserver)，用于在控制器工作时，为它追踪资源的度量数据。
## Kubernetes控制模式的工作原理
通过副本集(ReplicaSet)来创建Pod。可以在ReplicaSet资源的元数据中，描述你期望Pod副本数量(即spec.replacas的值)。
我们可以由Deployment来创建ReplicaSet，再由ReplicaSet来创建Pod，当我们更新了Deployment中的信息以后(比如更新了镜像版本)，部署控制器就回跟踪到新的期望状态，自动地创建新ReplicaSet，并逐渐缩减旧的ReplicaSet的副本数，知道到升级完成后，彻底删除掉旧ReplicaSet。
![[Pasted image 20240524103228.png]]
## `Kustomize`
## `HELM`
```bash
WordPress
 ├── templates
 │     ├── NOTES.txt
 │     ├── deployment.yaml
 │     ├── externaldb-secrets.yaml
 │     └── 版面原因省略其他资源文件
 │     └── ingress.yaml
 └── Chart.yaml
 └── requirements.yaml
 └── values.yaml
```
values.yaml给出了所有可配置项目的预定义值。
可配置项就是指需要部署期间由运维人员调整的那些参数，它们以花括号包裹在templates目录下的资源文件中。当部署应用时，Helm会先将管理员设置的值覆盖到values.yaml的默认值上，然后以字符串替换的形式，传递给templates目录的资源模版，最后生成要部署到Kubernetes的资源文件。
## Operator
> **Operator 设计理念**
> Operator是使用自定义资源(CR,即Custom Resource，是CRD的实例) 管理应用及其组件的自定义Kubernetes控制器。高级配置和设置由用户在CR中提供。Kubernetes Operator基于嵌入在Operator逻辑中的最佳实践，将高级指令转换为低级操作。Kubernetes Operator监视CR类型并采取特定于应用的操作，确保当前状态与该资源的理想续航太相符。

## 网络VXLAN
## 副本网卡：MACVLAN
## 容器间通信
所有的容器网络通信问题，其实都可以归结为本地主机内部的多个容器之间、本地主机与内部容器之间，以及跨越不同主机的多个容器之间的通信问题。
Docker提供了三种开箱急用的网络方案，它们分别为：
- 桥接模式，使用 `--network=bridge`指定，这种也是未指定网络参数的默认网络。
- 主机模式，使用 `--network=host`指定。主机模式下，Docker不会为新容器创建独立的网络名称空间，这样容器一切的网络设施，比如网卡、网络栈等，都会直接使用宿主机上的，容器也就不会拥有自己独立的IP地址。
- 控制模式，使用 `--network=none`指定。空置模式下，Docker会给新容器创建独立的网络名称空间，但是不会创建任何虚拟的网络设备，此时容器能看到的只有一个回环设备(Loopback Device)而已。
除了前面三种开箱急用的网络方案以外，Docker还支持由用户自行创建的网络，比如说：
- 容器模式
- MACVLAN模式
- Overlay模式
## 网络插件生态
这里的Underlay模式特指让容器和宿主机处于同一网络，两者拥有相同的地位的网络方案。Underlay网络要求容器的网络接口能够直接与底层网络进行通信，因此这个 `****` 模式是直接依赖于虚拟化设备与底层网络能力的。
## Static Provisioning
![[Pasted image 20240528105418.png]]
Kubernetes 对 PersistentVolumeClaim与PersistentVolume撮合的结果是产生一对一的绑定关系，意思是PersistentVolume一旦绑定在某个PersistentVolumeClaim上，知道释放以前都会被这个PersistentVolumeClaim所独占，不能再与其他PersistentVolumeClaim进行绑定。这也意味着即使PersistentVolumeClaim的存储空间比PersistentVolume能够提供的要少，依然要求珍格格存储空间都为该PersistentVolumeClaim所用，这有可能会造成资源的浪费。
## Dynamic Provisioning
Dynamic Provisioning 方案是指在用户声明存储能力的需求时，由特定的资源分配器(Provisioner) 自动地在存储资源池或者云存储系统中分配符合用户存储需要的PersistentVolume，然后挂载到Pod中使用，完成这项工作的资源被命名为StorageClass。
![[Pasted image 20240528111106.png]]
## 小结
容器是镜像的运行时实例，为了保证镜像能够重复地产出具备一致性的运行时实例，必须要求镜像本身是持久而稳定的，这就决定了在容器中发生的一切数据变动操作，都不能真正写入到镜像当中，否则必然会破坏镜像稳定不变的性质。

更合理的划分块存储、文件存储和对象存储的依据是，各种存储会提供什么形式的接口来供外部访问数据，而不同的外部访问接口会如何反过来影响存储的内部结构、性能与功能表现。
## 块存储
**块存储是数据存储最古老的形式**，它把数据都存储在一个或多个固定长度的块(Block)中、想要读写访问数据，就必须使用与存储相匹配的协议(SCSI、SATA、SAS、FCP、FCoE、iSCSI.....)。
**块存储由于贴近底层硬件，没有文件、目录、访问权限等的牵绊，所以性能通常都是最优秀的(吞吐量高，延迟低)。**
## 文件存储
**文件存储是最贴近人类用户的数据存储形式，** 数据存储在长度固定的文件之中，用户可以针对文件进行新增、写入、追加、移动、复制、删除、重命名等各种操作，通常文件存储还会提供有文件查找、目录管理、权限控制等额外的高级功能。
## 对象存储
**对象存储是相对较新的数据存储形式，它是一种随着云数据中心的兴起而发展起来的存储，是以非结构化数据为目标的存储方案。**
由于对象存储天生的分布式特性，以及极其低廉的扩展成本，使它很适合于CDN一类的应用，哪来存放图片、音视频等媒体内容，以及网页、脚本等静态资源。
**考虑到EFS的性能、动态弹性、可共享这些因素，我给出的明确建议是它可以作为大部分容器工作负载的首选存储。**
我们挂载外部存储的目的，十有八九就是为了给程序提供存储服务，而使用S3就不必写一行代码，就能直接通过HTTP Endpoint进行读写访问，而且完全不需要考虑容量、维护和数据丢失的风险。
除此之外，S3的另一大优势就是它的价格相对于EBS和EFS来说，往往要低一至两个数量级，因此程序的备份还原、数据归档、灾难恢复、静态页面的托管、多媒体分发等功能，就非常适合适合使用S3来完成。

# Kubernetes的资源模型与调度器设计
-  **处理器这样的资源，被叫做是可压缩资源(Compressible Resources)**，特点是当可压缩资源不足时，Pod只会处于 "饥饿状态"，运行变慢，但不会被系统杀死，或者是被要求限时退出。
- **而像内存这样的资源，则被叫做是不可压缩资源(Incompressible Resources)**，特点是当不可压缩资源不足，或者超过了容器自己声明的最大限度时，Pod就会因为内存溢出(OOM)而被系统直接杀掉。
## 服务质量等级
Kubernetes目前提供的服务质量等级一共分为三级，由高到低分别为Guaranteed、Burstable和BestEffort：
1. 如果Pod中所有容器都设置了limits和requests，且两者的值相等，那此Pod的服务质量等级就是最高的Guaranteed；
2. 如果Pod中有部分容器的requests值小于limits值，或者值设置了requests而未设置limits，那此Pod的服务质量等级就是第二级Burstable；
3. 如果limit和requests两个都没设置，那就是最低的BestEffort了。
## 优先级
Kubernetes还允许系统管理员自行决定Pods的优先级，这是通过类型为PriorityClass的资源来实现的。
## 驱逐机制
**Pod的驱逐机制是通过kubelet来执行的**，kubelet是部署在每个节点的集群管理程序，因为它本身就运行在节点中，所以最容易感知到节点的资源实时耗用情况。kubelet一旦发现某种不可压缩资源将要耗尽，就会主动终止节点上服务质量等级比较低的Pod，以保证其他更重要的Pod的安全。而被驱逐(Eviction)的Pod中，所有的容器都会被终止，Pod的状态会被更改为Failed。
- 软驱逐:一般会设置一个比较高的水位线，当触及此线时，系统会进入一段观察期，如果只是在那时的资源抖动，在观察期内能够恢复到正常水平的话，那就不会真正启动驱逐操作。否则，资源超过警戒线一段时间，就会触发Pod的优雅退出(Grace Shutdown).
- 硬驱逐:通常会设置一个比较高的终止线，一旦触及此线，系统就回立即强制杀掉Pod，不理会优雅退出。
**软驱动是为了减少资源抖动对服务的影响，硬驱逐是为了保障核心系统的稳定，它们并不矛盾，一般会同时使用**:
```bash
$ kubelet --eviction-hard=memory.available<10% \
      --eviction-soft=memory.available<20% \
      --eviction-soft-grace-period=memory.available=1m30s \
      --eviction-max-pod-grace-period=600
```

## 默认调度器
![[Pasted image 20240529150809.png]]
Informer Loop的职责是根据etcd中的资源变化，去更新调度队列(Priority Queue) 和调度缓存(Scheduler Cache) 中的信息。
另一个控制循环被称为"Scheduler Loop"，它的核心逻辑是不停地把调度队列中的Pod出队(Pop)，然后使用Predicate算法进行节点选择。
Kubernetes默认有三种过滤器策略，分别是：
- 通用过滤器策略
- 卷过滤器策略
- 节点过滤策略
