## Linux中的Namespace机制
Namespace的使用方式，其实知识Linux创建进程的一个可选参数。在Linux系统中创建进程的系统调用是clone(),比如：
```c
int pid = clone(main_function, stack_size, SIGCHLD, NULL);
```
这个系统调用会为我们创建一个新的进程，并且返回它的进程号pid。
而当我们用clone()系统调用创建一个新进程时，在参数中指定CLONE_NEWPID参数，比如：
```c
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);
```
这时，新创建的这个进程将会"看到"一个全新的进程空间，在这个进程空间里，它的PID是1。但是在宿主机真实的进程空间里，这个进程的PID还是真实的数值。
**这，就是Linux容器最基本的视线原理了。**
所以，Docker容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组Namespace参数。
**除了PID Namespace，Linux操作系统还提供了Mount、UTS、IPC、Network和User这些Namespace，用来对各种不同的进程上下文进行 "障眼法"操作。**
**在Linux内核中，有很多资源和对象是不能被Namespace化的，最典型的例子就是：时间。**
## Cgroups(Linux Control Group)
Cgroups最主要的作用，就是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等。
在Linux中，Cgroups给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的/sys/fs/cgroup路径下。
可以通过mount命令把它们展示出来，这条命令是：
```bash
mount -t cgroup
```
Linux Cgroups的设计还是比较易用的，简单粗暴地理解，它就是一个子系统目录加上一组资源限制文件的组合。而对于Docker等Linux容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组(即创建一个新目录)，然后在启动容器进程之后，把这个进程的PID填写到对应控制组的tasks文件中就可以了。
通过下面的命令对容器cpu进行限制：
```bash
docker run -d --cpu-period=100000 --cpu-quota=20000 {image}
```
**容器是一个"单进程"模型**
## 深入理解容器镜像
Mount Namespace 修改的，是容器进程对文件系统"挂载点"的认知。但是，这也就意味着，只有在 "挂载"这个操作发生之后，进程的视图才会被被改变。而在此之前，新创建的容器会直接继承宿主主机的各个挂载点。
**Mount Namespace跟其他Namespace的使用略有不同：它对容器进程视图的改变，一定伴随着挂载操作(mount) 才能生效。**

chroot(pivot_root)命令，它的作用就是帮你"change root file system",即改变进程的根目录到你指定的位置。
**实际上，Mount Namespace正是基于对chroot的不断改良才被发明出来的，它也是Linux操作系统里的第一个Namespace。**
我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如Ubuntu16.04的ISO。这样，在容器启动之后，我们在容器里通过执行 "ls/" 查看根目录下的内容，就是Ubuntu16.04的所有目录和文件。
**而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的"容器镜像"。它还有一个更为专业的名字，叫做：rootfs(根文件系统)。**
对Docker项目来说，它最核心的原理实际上就是为待创建的用户进程：
1. 启用Linux Namespace配置；
2. 设置指定的Cgroups参数；
3. 切换进程的根目录 (Change Root)。
**由于rootfs里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。**
## 通过aufs联合挂载的docker分层
![[Pasted image 20240531160932.png]]
**第一部分，只读层。**
## 第二部分，可读写层
为了实现在只读层的删除操作，AuFS会在可读写层创建一个whiteout文件，把只读层里的文件"遮挡"起来。
docker commit 和 push只保存这个修改过的可读写层，原先的只读层里的内容不会有任何变化，这，就是增量rootfs的好处。
## 第三部分，Init层。
这个层专门用来存放 `/etc/hosts`、 `/etc/resolv.conf`等信息，这些文件本来属于只读的镜像层的一部分，但是用户经常需要在启动容器是写入一些指定的值比如hostname，所以就需要在可读写层对他们进行修改，但是又希望执行docker commit时，不对这些信息连同可读写层一起被提交。所以，Docker的做法是，在修改了这些文件之后，以一个单独的层挂载出来。
![[Pasted image 20240531162127.png]]

## docker 小结
一个dockerfile示例：
```shell
# 使用官方提供的 Python 开发镜像作为基础镜像
FROM python:2.7-slim
 
# 将工作目录切换为 /app
WORKDIR /app
 
# 将当前目录下的所有内容复制到 /app 下
ADD . /app
 
# 使用 pip 命令安装这个应用所需要的依赖
RUN pip install --trusted-host pypi.python.org -r requirements.txt
 
# 允许外界访问容器的 80 端口
EXPOSE 80
 
# 设置环境变量
ENV NAME World
 
# 设置容器进程为：python app.py，即：这个 Python 应用的启动命令
CMD ["python", "app.py"]
```
```bash
$ ls

Dockerfile app.py requirements.txt
```
```bash
//制作镜像的命令
docker build -t helloworld .
```
如果想要上传到docker-hub,供他人使用，我们可以先执行docker tag 给容器镜像起一个完整的名字：
```bash
docker tag helloworld geektime/helloworld:v1
```

然后执行docker push:
```bash
docker push geektime/helloworld:v1
```
如果一个镜像运行过程，我们在容器里面做了一些操作，而且想把这些操作一同保存到镜像里面，我们可以使用docker commit,比如：
```bash
docker exec -it 4ddf4638572d /bin/bash
## 在容器内部新建了一个文件
root@4ddf4638572d:/app# touch test.txt

root@4ddf4638572d:/app# exit

# 将这个新建的文件提交到镜像中保存

docker commit 4ddf4638572d geektime/helloworld:v2
```
通过如下指令，可以看到当前正在运行的Docker容器的进程号：
```bash
docker inspect --format '{{ .State.Pid }}'  4ddf4638572d
```
这时可以通过查看宿主机的proc文件，看到这个进程的所有Namespace对应的文件：
```bash
ls -l /proc/3456069/ns
total 0

lrwxrwxrwx 1 root root 0 May 31 17:07 cgroup -> 'cgroup:[4026531835]'

lrwxrwxrwx 1 root root 0 May 31 17:07 ipc -> 'ipc:[4026532204]'

lrwxrwxrwx 1 root root 0 May 31 17:06 mnt -> 'mnt:[4026532202]'

lrwxrwxrwx 1 root root 0 May 31 17:06 net -> 'net:[4026532207]'

lrwxrwxrwx 1 root root 0 May 31 17:06 pid -> 'pid:[4026532205]'

lrwxrwxrwx 1 root root 0 May 31 17:07 pid_for_children -> 'pid:[4026532205]'

lrwxrwxrwx 1 root root 0 May 31 17:07 time -> 'time:[4026531834]'

lrwxrwxrwx 1 root root 0 May 31 17:07 time_for_children -> 'time:[4026531834]'

lrwxrwxrwx 1 root root 0 May 31 17:06 user -> 'user:[4026531837]'

lrwxrwxrwx 1 root root 0 May 31 17:07 uts -> 'uts:[4026532203]'
```
## Docker Volume
Docker Volume机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。
在Docker项目里，它支持两种Volume声明方式，可以把宿主机目录挂载进容器的 /test目录当中：
```bash
# Docker会默认在宿主机上创建一个临时目录
# /var/lib/docker/volumes/[VOLUME_ID]/_data
# 把这个目录挂载到容器起的/test目录上
docker run -v /test ...

# Docker 直接把宿主机的/home目录挂载到容器的/test目录上
docker run -v /home:/test ...
```
可以确认，容器Volume里的信息，并不会被docker commit提交掉；但这个挂载点目录/test本身，则会出现在新的镜像当中。
![[Pasted image 20240531180519.png]]
这个容器进程"python app.py"，运行在由 Linux Namespace 和 Cgroups构成的隔离环境里；而它运行所需要的各种文件，比如python，app.py，以及整个操作系统文件，则由多个联合挂载在一起的rootfs层一起提供。
这些rootfs层的最下层，是来自Docker镜像的只读层。
在制度层之上，是Docker自己添加的Init层，用来存放被临时修改过的 /etc/hosts 等文件。
而rootfs的最上层是一个可读写层，它以Copy-on-Write的方式存放任何对只读层的修改，容器声明的Volume的挂载点，也出现在这一层。