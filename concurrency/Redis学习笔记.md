## Redis的跳跃表
- 跳跃表是有序集合zset的底层实现之一
- 跳跃表支持平均O(logN)，最坏O(N)复杂度的节点查找，还可以通过顺序性操作批量处理节点。
- 跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(如表头节点、表尾结点、长度)，而zskiplistNode则用于表示跳跃表节点。
- 跳跃表就是在链表的基础上，增加了多集索引提升查找效率。
![[Pasted image 20240508100042.png]]
## 为什么Redis6.0之后改多线程呢？
- Redis6.0之前，Redis在处理客户端的请求时，包括读socket、解析、执行、写socket等都由一个顺序串行的主线程处理，这就是所谓的"单线程“.
- Redis6.0之前为什么一直不使用多线程？使用Redis时，几乎不存在CPU称为瓶颈的情况，Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。
Redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是单线程。
这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。

## RDB
RDB，就是把内存数据以快照的形式保存到磁盘上。
RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis重启的时候，通过加载dump.rdbwe文件来恢复数据。RDB粗发机制主要有以下几种：
![[Pasted image 20240508105506.png]]
RDB的有点
- 适合大规模的数据恢复场景，如备份，全量复制等
RDB缺点
- 没办法做到实时持久化/秒级持久化。
- 新老版本存在RDB格式兼容问题
## AOF
AOF(append only file)持久化，采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认是不开启的。
AOF的工作流程如下：
![[Pasted image 20240508110907.png]]
**AOF的有点**
- 数据的一致性和完整性更高
**AOF的缺点**
- AOF记录的内容太越多，文件越大，数据恢复变慢。

## Cluster集群模式
哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster集群应运而生，它在redis3.0加入的，实现了Redis的分布式存储。对数据进行分片存储。对数据进行分片，也就是说每台Redis节点上存储不同的内容，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。
- meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。
- ping消息：集群内交换最频繁的消息，集群内没给节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。
- pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。
- fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。
## Hash Slot插槽算法
插槽算法把整个数据库分为16384个slot(槽)，每个进入redis的键值对，根据key进行三列，分配到这个16384个插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。
集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数=16384/3，那么就有：
- 节点A负责0~5460号哈希槽
- 节点B负责5461~10922号哈希槽
- 节点C负责10923~16382号哈希槽

## Redis Cluster集群
Redis cluster集群中，需要确保16384个槽对应的node都正常工作，如果某个node出现故障，它负责的slot也会失效，整个集群将不能工作。
因此为了保证高可用，Cluster集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它节主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点宕机时，就会启用从节点。

讲完了RabbitMQ的消息模型，我们再来看看RocketMQ。RocketMQ使用的消息模型是标准的发布-订阅模型，在RocketMQ的术语表中，生产者、消费者和主体与我在上面讲的发布-订阅模型中的概念是完全一样的。

## RocketMQ中的分布式事务实现
![[Pasted image 20240509111427.png]]
我们可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在Producer端，我们给每个发出的消息附加一个连续递增的序号，然后在Consumer端来检查这个序号的连续性。
如果没有消息丢失，Consumer收到的消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号+1.如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。
大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在Producer发送消息之前的拦截器中将序号注入到消息中，在Consumer收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检查的逻辑关闭或者删除。

## 确保消息可靠传递

## 收款账户和收单账户
当电商要对接银行时，往往会被要求开设一个收款账户。用户通过这个银行来支付时，钱就被转到这个账户上。对第三方支付也是一样。收款账户是开设在银行或者第三方支付这边的，即渠道侧。一般来说，渠道每天都可以提供这个账户的交易流水供电商对账用。这样在电商这边，渠道就成为一个收单机构。所以在电商这边，建立这个收款账户对应的对账用的收单账号，用来记录通过这个渠道进行的各项交易流水。

## 支付网关
在支付系统中，支付网关和支付渠道的对接是最核心的功能。其中支付网关是对外提供服务的接口，所有需要渠道支持的资金操作都需要通过网关分发到对应的渠道模块上。一旦定型，后续就很少，也很难调整。而支付渠道模块是接收网关的请求，调用渠道接口执行真正的资金操作。每个渠道的接口，传输方式都不尽相同，所以在这里，支付网关相对于支付渠道模块的作用，类似设计模式中的wrapper，封装各个渠道的差异，对网关呈现统一的接口。而网关的功能是为业务提供通用接口，一些和渠道交互的公共操作，也会放置到网关中。

## 支付产品
## 快捷支付
用户在完成绑卡之后，在支付的时候，不需要再输入卡或者身份信息，仅需要输入支付密码就可以完成支付。对于小额度的支付，甚至可以开通小额免密，直接完成支付。这种支付方式不会打断用户的体验，是目前主要的在线支付方式。一般快捷支付产品是通过封装银行或者第三方支付平台提供的快捷支付接口或者代付接口来实现的。
## 网银支付
用户在支付的时候，需要跳转到银行网银页面来完成支付。在网银页面，需要输入用户的卡号和身份信息。这种支付方式会中断用户当前的体验，一般用于PC Web上的支付。网银支付是封装银行提供的网银支付来实现的。
## 协议支付
协议支付也称为代收或者代扣，代收渠道授权商户可以从用户的银行账户中扣款，一般用于定期扣款，不用于日常消费。比如水电煤气、有线电视费。协议支付是通过封装银行、第三方支付提供的代扣或者快捷接口来实现的。
## 平台支付
使用微信、支付宝等第三方支付平台来完成支付。使用时，一般需要用户预先安装支付平台系统，注册并登录到第三方支付平台，并且已经在该平台上完成绑卡等操作。由于微信、支付宝已经被大量使用，用户也产生对这些平台的信任，平台支付往往是电商公司的主要支付方式。
## 话费支付
对于有包月小额类型的支付，手机话费也是一个不错的选择。目前也有一些平台可以支持话费支付，比如虹软、联动优势等。
## 外卡支付
对于海外支付的需求，还需要提供外卡支付支持。国内不少支付渠道都能支持外卡支付，如支付宝全球购等。直接对接paypal，也是目前用的最多的外卡支付渠道。
## 虚币支付
不少公司会有自己的虚拟币，比如京豆、Q币等。这些虚拟币也可以作为一种支付方式。
## 账户支付
也称为余额支付、零钱支付等。指为用户建立本地账户，支持充值，之后可以使用这个账户来完成支付。
## 信用支付
如京东白条，蚂蚁花呗，指使用信用账户进行透支，类似信用卡支付。
## 代付
和代扣相反，代付是平台将钱打给用户。
每一种支付方式的详细功能将在后续的各个章节中介绍。这里先简要介绍支付产品模块的通用功能。

如果业务大到需要分表才能处理，那对账数据准备也不一样。使用分库也不现实，因为分库一般是按照主体id，而不是渠道id，来分库，这样对账就需要再多个库上进行，效率反而降低了。而对分表分库建立从库也非常耗费资源。这种情况下，需要同步一份数据到文件系统，或者NOSQL数据库上。

## 轧账
推荐采用mapreduce来轧账，这有个优势，可以按照订单号将渠道提供的记录和本地记录shuffle到同一个reduce处理上，这样就可以很容易进行数据对比。轧账中最大的坑莫过于切分点的问题。比如以整0点为切分点，那存在一个问题，本地23:59发起的交易，到了渠道侧，可能会在00:01处理，这笔交易变成第二天的帐了。实际处理中，一笔交易在渠道侧处理，花上几分钟都有可能。对于切分点附近无法确认的帐，做一个时间窗，在时间窗内的数据，留待第二天对账时继续处理。
## 平账
发现两边不一致的数据，那应该如何处理？数据量不大时，记录起来，人工甄别就行。但如果数据量很大，每天上欠条，人工处理就成本太高了。这个没有统一的处理方法，需要根据有问题的数据，做个分析，然后做自动处理。针对交易记录的对账处理，主要有如下情况：
- 长款：本地未支付，支付渠道已支付。这主要是本地未接收到渠道下发的异步通知导致。一般处理是将本地状态修改为已支付，并做响应的后续处理，比如通知业务员放灯。
- 短款：本地已支付，但是支付渠道中无记录；或者本地无记录，支付渠道有记录。在排除跨日因素外，这种情况非常少见，需要交接具体原因后做处理。
- 金额不一致：本地已支付，支付渠道已支付，但是金额不同，这个需要人工核查。
针对退款的对账处理，主要有如下情况：
- 本地未退款，支付渠道已退款，则以支付渠道为准，修改本地为已退款状态，并触发后续处理。
- 本地已退款、支付渠道已退款，但是金额不同，需要人工核查；
- 本地已退款，但是支付渠道无记录；或者支付渠道有记录，但是本地没有。在排除跨日因素外，这种情况非常少见，需要了解具体原因后做处理。
## 计算因子
路由规则是支付路由的核心。在规则设置上，需要和公司的业务、支付服务的scope来综合考虑。这里讲述的是通用的规则设计，供具体实现实现时参考。
**支付类型**当然，路由时首选需要考虑渠道可以支持的支付产品。

- 渠道费率：渠道的手续费，这里假定工行是按支付金额收费，比例为支付金额的0.1%。
- 渠道费用：这里是支付金额*手续费，即0.1元。
- 发起交易日期：2016年12月12日 13:00:10，即用户提交订单后，虚拟产品业务调用支付系统接口执行支付的时间。
封装集群：Kubernetes
如果说以Docker为代表的容器引擎，是把软件的发布流程从分发二进制安装包，转变为直接分发虚拟化后的整个运行环境，让应用实现跨机器的绿色部署；那以Kubernetes为代表的容器编排框架，就是把大型软件系统运行所依赖的集群环境也进行了虚拟化，让集群得以实现跨数据中心的绿色部署，并能够根据实际情况自动扩缩。

会计要素是对会计对象进行的基本分类，是会计核酸对象的具体化。如果说对象是个Object，则会计要素是定义这个Object的Class。不同的国家对会计要素有不同的规定。国际会计准则委员会(IASC)在《编制和呈报财务报表的结构》将会计要素归类为资产、负债、权益、收益和费用五个要素。美国财务会计准则委员会(FASB)在《财务会计概念公告》中将会计要素归类为资产、负债、所有者权益(净资产)、业主投资、派给业主款、综合收益、营业收入、费用、利润、损失是个要素。我国《会计准则》将会计要素归类为资产、负债、所有者权益、收入、费用和利润六个要素。其中资产、负载和所有者权益，是反映公司的财务状况的；它满足如下恒等式：
资产 = 负债+所有者权益
收入、费用和利润，是反映公司动态的经营成果，满足如下恒等式：
收入-费用=利润
## 会计科目
六大会计要素指明了需要记账的scope，但毕竟粒度还是太大了。
## 会计账户
账户是指对会计要素的具体内容所做的科学的分类，其包括两方面的内容：账户的名称、账户的用途与结构。会计科目是设置账户的依据，也是账户的名称。
## 银行直连
用户通过工行支付的款项，在银行侧并不是直接落到老熊公司的结算账户上，而是先到一个中间账户上。这就需要了解银行侧的账户和资金处理流程。针对第三方支付和电商直连银行，在银行侧的账户和资金处理流程是不一样的。电商公司直连银行，不需要复杂的备付金管理。当电商公司(第三方支付公司类似)和工行签约开通支付接口后，工行会为这个接口开设一个结算账户。通过这个接口流转的资金最终会结算到这个账户上。这也是电商公司可以提现的一个账户。另外，为了方便资金清算，工行还会为电商公司设一个收付账户，这个账户是直接对接线上资金处理得，这是工行内部账户，电商公司无法操作这个账户，但是可以看到这个账户的收付情况。
## 支付时，资金在工行侧的流转流程：
1. 用户提交支付请求，支付系统调用工行快捷支付接口执行支付。
2. 工行服务器检查用户账户余额和状态，如果余额不足或者状态异常，则停止支付。继续检查电商公司的收款账户的状态。如果状态正常，开始执行支付。资金从用户账户转到收付账户上。
3. 工行采用T+1的结算，将T日用户支付的所有款项，扣除退款，扣除手续费用后，将剩余资金打入电商结算账户上。
## 第三方支付平台
对于没有直连的银行，可以通过第三方支付来收款。第三方支付侧的资金处理，和银行的类似。以支付宝为例，当商家在支付宝开通支付接口后，支付宝为商家建立账户以及商户号。每个业务对应一个商户号。用户提交支付后，支付宝完成收款后，直接进行分润，扣除手续费，将剩余资金转移到商户号上。
这里记为应收账款，因为T+1后，支付宝还要将资金按照商户的要求，转移到指定银行账户上。假定这个银行账户为建行的账户，当天收入为200万元，手续费为2千元，对应的会计分录为：
## 备付金
当用户确认接收到商品后，资金从第三方支付公司转到商家账户上。这个资金被称为备付金。即"指支付机构为办理客户委托的支付业务而实际收到的预收待付资金“。备付金由银行托管，备付金银行分为存管银行和合作银行。
- 存管银行只能有一家，负责处理备付金跨行收付，并对支付机构存放的各银行的备付金信息做归集，合并与监督。
- 合作银行可以有多家，可以办理针对本银行的备付金存取和监管。
和备付金相关的账户有三类：
- 存管账户：可以以现金形式接收客户备付金、以银行转账方式办理客户备付金收取和支取业务的专用存款账户。
- 收付账户：可以以现金形式或以银行转账方式接收客户备付金、以银行资金内部划转方式办理客户备付金支取业务的专用存款账户。
- 汇款账户：仅支持同行收款以及退款时原路退回。

## 充值
使用虚户时，电商需要为客户和商户建立内部账户。这个内部账户，对电商公司来说，需要记录在负债上。
回到充值的案例：用户使用工行的卡，给自己的账户充值100块钱，不考虑手续费，会计分录为：
资金先进入应收账款，因为充值和支付一样，资金也是在清结算完成后才到账的。用户在其他航充值情况应该如何处理？如果电商公司和这个银行有
电商提现的主要途径是银企直联、企业网银和第三方支付代付。
## 银企直联
对于商户和客户规模不大的公司，通过将公司内部的ERP、财务系统等业务系统和银行接口对接，实现银企直联，可以让财务人员通过内部业务系统来打款。
## 银企网银
一般银行都提供的企业网银接口，支持同行批量打款(代付)功能。