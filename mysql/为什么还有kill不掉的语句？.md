在Mysql中有两个kill命令：一个是 kill query + 线程id，表示终止这个线程中正在执行的语句；一个是 kill connection + 线程 id，这里connnection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。

## 收到 kill 以后，线程做什么？
但是，这里你要停下来想一下：session B是直接终止掉线程，什么都不管就直接退出吗？显然，这是不行的。

由于Mysql是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl + C的时候，是Mysql客户端另外启动一个连接，然后发送一个kill query命令。
所以，你可别以为在客户端执行完Ctrl + C就完事大吉了。因为，要kill掉一个线程，还涉及到后端的很多操作。

## 关于kill不掉的小结
这些 "kill 不掉"的情况，其实是因为发送kill命令的客户端，并没有强行停止目标线程的执行，而只是设置了个状态，并唤醒对应的线程。而被kill的线程，需要执行到判断状态的 "埋点"，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。
所以，如果你发现一个线程处于Killed状态，你可以做的事情就是通过影响系统环境，让这个Killed状态尽快结束。

## 全表扫描对 server 层的影响
你已经知道了，InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。
那么，这个 ”结果集” 存在哪里呢？
实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：
1. 获取一行，写到net_buffer中。这块内存的大小是由参数 net_buffer_length 定义的，默认是16k。
2. 重复获取行，知道net_buffer写满，调用网络接口发出去。
3. 如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。
4. 如果发送函数返回EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈 (socket send buffer) 写满了，进入等待。直到网络栈重新可写，再继续发送。
```ad-note
通过 show processlist命令，如果看到State的值一直处于“Sending to client”， 就表示服务端的网络栈写满了。
前面提到的，如果客户端使用-quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。如果业务比较复杂，处理的速度很慢，就可能导致网络栈写满后进入等待状态。
因此，对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。
```

现在我们知道了，查询的结果是分段发送给客户端的，因此全表扫描，查询返回大量的数据，并不会把内存打爆。

## 全表扫描对InnoDB的影响
如果buffer pool的内存数据页的结果是最新的，查询的时候就直接读内存。buffer pool除了可以加速写，还可以加速读。
而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：内存命中率。通过执行 `show engine innodb status`, 可以看到 "Buffer Pool hit rate" 字样，显示的就是当前的命中率，一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。InnoDB Buffer Pool的大小是由参数innodb_buffer_size确定的，一般建议设置为物理内存的 60%~80%。
InnoDB内存管理采用LRU算法，但是InnoDB对该算法进行了改进，按照5:3的比例吧整个LRU链表分成了young 区域和 old区域。
![[Pasted image 20240103152004.png]]
1. young区域中内存命中后，跟普通LRU一样，将命中的数据移动到链表头部。
2. 但是要访问一个当前链表中不存在的数据页，如果Buffer Pool已满，需要淘汰掉链表尾部(也就是old区域的尾部page)，最新被访问的数据页在old区域的头部被插入。
3. 处于old 区域的数据页，每次被访问的时候都要做下面这个判断：
	- 若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；
	- 如果这个数据页在LRU链表中存在的时间短语1秒，位置保持不变。1秒这个时间，是由参数 innodb_old_blocks_time控制的。其默认值是 1000，单位毫秒。
这个策略最大的收益，就是在扫描大表的过程中，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。

## 到底可不可以使用join
这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，索引我们称之为 "index Nested-Loop Join",简称为NLJ。
如果被驱动表能用上索引，每次只扫描1行，这样join查询扫描次数是驱动表扫描行数 + 执行了多少次被驱动表的扫描次数，这种情况明显是使用join更划算，如果把join拆开需要多执行很多条语句的交互。
## 怎么选择驱动表
在这个join语句的执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。
假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再所有主键索引。每次搜索一棵树近似复杂度已2位底的M的对数，记为log2M,所以在被驱动表上差一行的时间复杂度是`2*log2M`。
假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。
因此整个执行过程，近似复杂度是 `N + N*2*log2M`。
显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。
通过上面的分析我们得到了两个结论：
1. 使用join语句，性能比强行拆成多个单标执行SQL语句的性能要好；
2. 如果使用join语句的话，需要让小表做驱动表。
但是需要注意，这个结论的前提是 "可以使用被驱动表的索引"。

## 如果被驱动表没有可用的索引，Mysql8.0之前的版本使用的Block Nested-Loop Join，8.0引入了hash join优化
```sql
select * from t1 straight_join t2 on (t1.a=t2.b);
```
1. 把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是 `select *`，因此是把整个表t1放入了内存；
2. 扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。
这个过程的流程如下：
![[Pasted image 20240103180332.png]]
如果join_buffer_size不足以容纳驱动表的所有行，需要进行分段join，假设分段次数为K，K越大扫描被驱动表的次数越多，而又由于分段join和不分段的join在内存中的判断次数是一样的，所以分段的次数越少越好，所以就有了两个优化的结论：
1. 尽量用小表做为驱动表
2. 当我们join语句很慢的时候，就可以通过吧join_buffer_size改大来优化。

**在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是 "小表"，应该作为驱动表。**

## Multi-Range Read 优化
MRR优化的主要目的是尽量使用顺序度盘。
**因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。**

那怎么才能一次性地多传些值给表t2呢？方法就是，从表t1里一次性地多拿些行出来，一起传给表t2.
既然如此，我们就把表t1的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是join_buffer。
MRR能够提升性能的核心在于，这条查询语句在索隐a上做的是一个范围查询 (也就是说，这是一个多值查询)，可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出 "顺序性" 的优势。
## Batched Key Access
BKA算法是对NLJ算法的优化
怎么启动BKA优化算法，你需要在执行SQL语句之前，先设置
```sql
set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';
```
其中，前两个参数的作用是要启用MRR。这么做的原因是，BKA算法的优化要依赖于MRR。
BKA算法的流程如下图：
![[Pasted image 20240104145352.png]]

## BNL 转 BKA
一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转BKA算法了。
但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：
```sql
select * from t1 join t2 on (t1.b = t2.b) where t2.b >= 1 and t2.b <= 2000;
```

## 临时表在使用上有以下几个特点：
![[Pasted image 20240104153111.png]]
1. 建表语法是 `create temporary table ...`。
2. 一个临时表只能被创建它的session访问到，对其他线程不可见。所以，图中session A创建的临时表t，对于session B是不可见的。
3. 临时表可以与普通表同名。
4. session A内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。
5. show tables 命令不显示临时表。

由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。

## 临时表的应用
由于不用担心线程之间的重命名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。
一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。
一般情况下，这种分库分表系统都有一个中间层proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有proxy这一层。
在这个架构中，分区key的选择是 "以减少跨库和跨表查询"为依据的。如果大部分语句都会包含f的等值条件，那么就要用f做分区键。这样在proxy一层解析完sql语句以后，就能确定将这条语句路由到哪个分表做查询。
但是存在特殊的查询语句，可能不包含分区键的等值条件，这种情况有两种比较常用的思路。
**第一种思路是，在proxy的进程代码中实现排序**
这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：
1. 需要的开发工作量比较大。如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；
2. 对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题。

**另一种思路就是，把各个分库拿到的数据，汇总到一个Mysql实例的表中(该汇总表一般是临时表)，然后再这个汇总实例上做逻辑操作。**
在实践中，我们往往会发现每个分库的计算量都不饱和，所以直接把临时表放到分库中的某一个上面。

## 为什么临时表可以重名？
创建临时表时，Mysql要给这个表创建一个frm文件保存表结构定义，还要有地方保存数据。
这个frm文件放在临时文件目录下，文件名的后缀是.frm,前缀是 `"#sql{进程id}_{线程id}_序列号"`。可以使用`select @@tmpdir`命令，来显示实例的临时文件目录。

而关于表中数据的存放方式，在不同的Mysql版本中有着不同的处理方式：
- 在5.6以及之前的版本里，Mysql会在临时文件目录下创建一个相同前缀、以.idb为后缀的文件，用来存放数据文件；
- 而从5.7版本开始，Mysql引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建idb文件了。
Mysql维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。
- 一个普通表的table_def_key的值是由"库名 + 表名"得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key 已经存在了。
- 而对于临时表，table_def_key 在 "库名 + 表名"基础上，又加入了 "server_id + thread_id"。
在是线上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 "DROP TEMPORARY TABLE + 表名" 操作。

## 临时表和主备复制
如果binlog的格式是row，临时表的操作被改写为相应的前后的数据表示，但如果是statement或者mixed，会将主库上面执行临时表的相关命令原样保存到binlog文件中，但是由于binlog同步到备库上面需要将主库执行的关于临时表的操作命令是那个线程执行的相关信息也记录下来，因为备库sql同步线程可能会在同一个线程上创建相同名称的临时表，报错导致同步停止，即便有多线程复制的优化也没办法避免会在同一个线程上执行相同临时表相关的操作，最后主库session退出的时候需要将drop temporary table也写入binlog中，因为备库的同步线程不会跟主库的线程那样是执行完就退出了。

## 为什么使用内部临时表
union执行时需要通过给临时表加唯一性约束来达到去重的目的，如果是union all没有去重的语义，这样执行的时候，就依次执行子查询，得到结果直接作为结果集的一部分，发给客户端。因此也就不需要临时标了。

group by也会使用内存临时表，如果group by的中间结果比较大，超过了参数 tmp_table_size配置的大小(默认16M，但是我查看mysql8在windows上默认是14M)，就会把内存临时表转成磁盘临时表，磁盘临时表使用的引擎是InnoDB。
在Mysql 5.7版本支持了 generated column机制，用来实现列数据的关联更新。例如：
```sql
alter table t1 add column z int generated always as(id % 100), add index(z);
```
InnoDB的索引可以满足输入有序的条件，所以通过这个z的索引就可以避免group by使用临时表。

对于数据量很大的group by查询语句，我们可以通过SQL_BIG_RESULT这个提示 (hint),就可以告诉优化器：这个语句设计的数据量很大，请直接使用磁盘临时表，避免由于内存临时表空间不够，又要重新转成磁盘临时表。
```sql
select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;
```
![[Pasted image 20240105110721.png]]
从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。以此来看，mysql8.0针对这种大数据量的group by还是会进行排序，不使用该提示的不会进行排序。

**Mysql什么时候会使用内存临时目录？**
1. 如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；
2. join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；
3. 如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束，group by 还需要用到另外一个字段来累计计数。

## 内存表的数据组织结构
与InnoDB引擎不同，Memory引擎的数据和索引是分开的。
- InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这方式，我们称之为**索引表**(index Organized Table)。
- 而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为**堆组织**(Heap Organized Table)。
InnoDB引擎和Memory引擎的典型区别：
1. InnoDB表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；
2. 当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证有序性，只能在固定位置写入新值，而内存表找到空位就可以插入新值；
3. 数据位置发生变化的时候，InnoDB只需要修改主键索引，而内存表需要修改所有索引；
4. InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的 "地位" 都是相同的。
5. InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。

## hash索引和B-Tree索引
实际上，内存表也是支持B-Tree索引的。
```sql
alter table t1 add index a_btree_index using btree (id);
```

**内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作**
线上不建议使用内存表来替代普通表来使用，虽然内存表的数据是存在内存中，但是它存在很多问题，主备同步的时候，如果有一个节点重启，内存中的数据就会丢失，导致主备同步停止，内存表只支持表锁，所以锁的粒度过大，导致并发性能不是很高，建议用Innodb替代，innodb支持行锁，并且在数据量不是很大的情况下，innodb表中的数据有可能也全部都在buffer pool中。
但是可以使用内存临时表来替代innodb临时表，临时表由于是线程隔离的，所以不存在并发场景。数据如果丢了，继续之前的流程将临时表重新填充即可，内存临时表支持hash索引，查找的速度会更快。
