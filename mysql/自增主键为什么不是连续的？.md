不同的引擎对于自增值的保存策略不同。
- MyISAM引擎的自增值保存在数据文件中。
- InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了 "自增持久化"的能力，也就是才实现了 "如果发生重启，表的自增值可以恢复为MySQL重启前的值"，具体情况是：
	- 在Mysql 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将max(id)+1作为这个表当前的自增值。
	- 在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。
## 自增值的修改时机
```sql
insert into t values(null, 1, 1);
```
这个语句的执行流程是：
1. 执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0, 1, 1);
2. InnoDB发现用户没有指定自增id的值，获取表t当前的自增值，假设是2；
3. 将传入的行的值改为(2, 1, 1);
4. 将表的自增值改为3；
5. 但是由于c有唯一索引约束，所以报Duplicate key error，语句返回。

## 自增锁的优化
可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。

在Mysql5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。
Mysql 5.1.22版本引入了一个新策略，新增参数 innodb_automic_lock_mode，默认值是1，但是8.0默认值是2.
1. 这个参数的值被设置为0时，表示采用之前Mysql5.0版本的策略，即语句执行结束后才释放锁；
2. 这个参数的值被设置为1时：
	- 普通insert语句，自增锁在申请之后就马上释放；
	- 类似 insert ... select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
3. 这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。
![[Pasted image 20240105170216.png]]
上图中两个session找那个最后一个insert语句是并发执行的，所以谁先执行不确定的，但是两个session写binlog文件是有先后顺序的，如果binlog_format=statement,这样就会导致备库中同步该binlog会出现跟主库中执行主键id不一致的问题。
因此设置为1可以让原库的批量插入语句 (inser... select),固定生成连续的id值。因为设置为1是等语句执行完成后才会释放自增锁。
设置为2，并且binlog_famat=row,由于binlog是如实记录了插入数据的所有值，同步到备库主键值不会改变，也就不会出现这个id不一致的问题。

对于预先不知道要申请多少个自增id的批量插入语句，Mysql有一个批量申请自增id的策略：
1. 语句执行过程中，第一次申请自增id，会分配1个；
2. 1个用完以后，这个语句第二次申请自增id，会分配2个；
3. 2个用完以后，还是这个语句，第三次申请自增id，会分配4个；
4. 依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。

## mysqldump 快速导出 db1.t里面 a>900的数据
```shell
mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-info --single-transaction --set-gtid-purged=OFF db1 t --where='a>900' --result-file=/client_tmp/t.sql
```
这条命令中，主要参数的含义如下：
1. --single-transaction 的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT 的方法；
2. --add-locks设置为0，表示在输出的文件结果里，不增加 "LOCK TABLES t WRITE;";
3. --no-create-info 的意思是，不需要导出表结构；
4. --set-gtid-purged=off 表示的是，不输出跟GTID相关的信息；
5. --result-file 指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。
## 导出CSV文件
```sql
select * from db1.t where a>900 into outfile '/server_tmp/t.csv';
```
得到.csb导出文件后，可以用下面的 load data 命令将数据导入到目标表 db2.t中。
```sql
load data infile '/server_tmp/t.csv' into table db2.t;
```
这条语句的执行流程如下所示:
1. 打开文件 /server_tmp/t.csv，以制表符 (`\t`) 作为字段间的分隔符，以换行符 (`\n`) 作为记录之间的分隔符，进行数据读取；
2. 启动事务。
3. 判断每一行的字段数与表 db2.t是否相同；
	- 若不相同，则直接报错，事务回滚；
	- 若相同，则构成一行，调用InnoDB引擎接口，写入到表中。
4. 重复步骤3，直到 `/server_tmp/t.csv` 整个文件读入完成，提交事务。

按照用户权限范围从大到小的顺序依次和你说明。
## 全局权限
全局权限，作用于整个Mysql实例，这些权限信息保存在mysql库的user表中。如果我要给用户 ua赋一个最高权限的话，语句是这么写的：
```sql
grant all privileges on *.* to 'ua'@'%' with grant option;
```
这个grant命令做了两个动作：
1. 磁盘上，将mysql.user表里，用户 'ua'@'%'这一行的所有表示权限的字段的值都修改为 'Y';
2. 内存里，从数据acl_users 中找到这个用户对应的对象，将access值 (权限位) 修改为二进制的 "全1"。

回收用户权限的命令：
```sql
revoke all privileges on *.* form 'ua'@'%';
```
这条revoke命令的用法与grant类似，做了如下两个动作：
1. 磁盘上，将mysql.user表里，用户 'ua'@'%' 这一行的所有表示权限的字段的值都修改为 'N';
2. 内存里，从数组acl_users 中找到这个用户对应的对象，将access的值修改为0。
## db权限
给ua用户分配db1的所有权限，可以执行如下命令：
```sql
grant all privileges on db1.* to 'ua'@'%' with grant option;
```
基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。

## join疑问
使用left join时，左边的表不一定是驱动表。如果需要left join的语义，就不能把驱动表的字段放在where条件里面做成等值判断或不等值判断，必须都写在on里面。

## Simple Nested Loop Join 的性能问题
BNL 算法的执行逻辑是：
1. 首先，将驱动表的数据全部读入内存 join_buffer中，这里join_buffer是无序数组；
2. 然后，顺序遍历被驱动表的所有行，每一行都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。
Mysql中索引结构和Buffer Pool的相关知识点：
1. 在对被驱动表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；从磁盘读入数据到内存，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部；
2. 即使驱动表都在内存，每次查找 "下一个记录的操作"，都是类似指针操作。而join buffer中是数组，遍历的成本更低。
