下图为一主一备的架构：
![[Pasted image 20240131150703.png]]
**节点A到节点B这条线的内部流程如下图所示：**
![[Pasted image 20240131150752.png]]
可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。
备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：
1. 在备库B上通过change master命令，设置主库的IP、端口、用户名、密码，以及要从那个位置开始请求binlong，这个位置包含文件名和日志偏移量。
2. 在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。
3. 主库A检验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。
4. 备库B拿到binlog后，写到本地文件，称为中转日志 (relay log)。
5. sql_thread 读取中转日志，解析出日志里的命令，并执行(sql_thread后来演化成为了多个线程)。


一般是将binlog设置为row格式，通过将主库的binlog在备库中重放执行，来保证主备数据一致。binlog有三种格式：
1. statement格式：原样记录已经执行过的sql语句(这种情况可以减小binlog文件的大小, 但是容易造成主备不一致)。
2. row格式：二进制格式，通过记录update sql执行前后数据的差异。(可以有效的保证主备数据同步时数据的一致性，但是binlog文件可能会比较大)。
3. mixed格式：结合statement和row格式的有点，mysql自身会根据sql语句是否会影响数据一致性的问题来判断是使用statement格式还是使用row格式来存储binlog日志。
## 循环复制问题
通过上面对Mysql中binlog基本内容的理解，你现在可以知道，binlog的特性确保了再备库执行相同的binlog，可以得到与主库相同的状态。
因此，我们可以认为正常情况下主备的数据是一致的。也就是说，图1中A、B两个节点的内容是一致的。其实，图1中我画的M-S结构，但实际生产上使用比较多的是双M结构，也就是图9所示的主备切换流程。

但是，双M结构还有一个问题需要解决。
业务逻辑在节点A上更新了一条语句，然后把binlog发给节点B，节点B执行完这条更新语句后也会生成binlog。(我建议你把参数log_slave_updates 设置为on，表示备库执行replay log后生成binlog)。
那么，若果节点A同事是节点B的备库，相当于又把节点B新生成的binlog拿过来执行一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？
从上面的图6中可以看到，Mysql在binlog中记录了这个命令第一次执行时所在实例的server id。因此，我们可以用下面的逻辑，来解决两个节点间的循环复制问题：
1. 规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；
2. 一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新binlog；
3. 每个库在收到从自己的主库发过来的日之后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。
按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：
1. 从节点A更新事务，binlog里面记得都是A的server id；
2. 传到节点B执行一次以后，节点B生成的binlog的server id也是A的server id；
3. 再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。
