主动切换场景与数据同步有关的时间点主要包括以下三个：
1. 主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1；
2. 之后传给备库B，我们把备库接收完这个binlog的时刻记为T2；
3. 备库B执行完成这个事务，我们把这个时刻记为T3.

所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，就就是T3 - T1

你可以在备库上执行 show slave status命令，它的返回结果里面会显示seconds_behind_master,用于表示当前备库延迟了多少秒。

seconds_behind_master的算方法是这样的：
1. 每个事务的binlog里面都有一个时间字段，用于记录主库上写入的时间；
2. 备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。
可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_msater来作为主备延迟的值，这个值的时间精度是秒。
你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？
其实不会的。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行sconds_behind_master计算的时候会自动扣掉这个差值。
```ad-note
备注：这里需要说明一下，从库和备库在概念上其实差不多。在我们这个专栏里，为了方便描述，我把会在HA过程中被选成新主库的，称为备库，其他的称为从库。
```

## 可靠性优先策略
在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：
1. 判断备库B现在的seconds_behind_master,如果小于某个值 (比如5秒) 继续下一步，否则持续重试这一步；
2. 把主库A改成只读状态，即把readonly设置为true;
3. 判断备库B的seconds_behind_master的值，知道这个值变为0为止；
4. 把备库B改成可读写状态，也就是吧readonly设置为false；
5. 把业务切到备库B。
## 可用性优先策略
如果强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。

## 可靠性优先策略
聊到这里你就知道了，在满足数据可靠性的前提下，Mysql高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。


## Mysql 5.6只支持按库并行的粒度，看下MariaDB 的并行复制策略
在第23篇文章中，我给你介绍了redo log组提交 (group commit) 优化，而MariaDB的并行复制策略利用的就是这个特性：
1. 能够在同一组里提交的事务，一定不会修改同一行；
2. 主库上可以并行执行的事务，备库上也一定是可以并行执行的。

在实现上，MariaDB是这么做的：
1. 在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id + 1；
2. commit_id直接写到binlog里面；
3. 传到备库应用的时候，相同commit_id的事务分发到多个worker执行；
4. 这一组全部执行完成后，coordinator再去取下一批。
但是，这个策略有一个问题，它并没有实现"真正的模拟主库并发度"这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于 "执行中"状态的。
![[Pasted image 20231229173451.png]]
可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。
另外，这个方案很容易被大事务拖后腿。

## Mysql 5.7 的并行复制策略
在MariaDB并行复制实现之后，官方的Mysql5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：
1. 配置为DATABASE，表示使用Mysql 5.6版本的按库并行策略；
2. 配置为LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，Mysql 5.7这个策略，针对并行度做了优化。
3. ![[Pasted image 20231229174207.png]]
其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了。

Mysql 5.7并行复制策略的思想是：
1. 同时处于prepare状态的事务，在备库执行时是可以并行的；
2. 处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。

## Mysql 5.7.22的并行复制策略
Mysql增加了一个新的并行复制策略，基于WRITESET的并行复制。
相应的，新增了一个参数binlog-transaction-dependency-tracking, 用来控制是否启用这个新策略。这个参数的可选值有以下三种：
1. COMMIT_ORDER,表示的就是前面介绍的，根据同事进入prepare和commit来判断是否可以并行的策略。
2. WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。
3. WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在准备执行的时候，要保证相同的先后顺序。
从这些分析中，你也会发现大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。
官方Mysql5.7版本新增的备库并行策略，修改了binlog的内容，也就是说binlog协议并不是向上兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。

# 主库出问题，从库该怎么办

## 基于位点的主备切换
一种取同步位点的方法是这样的：
1. 等待新主库A'把中转日志 (relay log) 全部同步完成；
2. 在A'上执行show master status命令，得到当前A'上最新的File和Position；
3. 取原主库A故障的时刻T；
4. 用mysqlbinlog工具解析A'的File，得到T时刻的位点。
```shell
mysqlbinlog File --stop-datetime=T --start-date=T
```
![[Pasted image 20231229181306.png]]
1. 在从库B上，由于同步了binlog，R这一行已经存在；
2. 在新主库A’上，R这一行也已经存在，日志写在123这个位置之后的；
3. 我们在主库B上执行change master命令，指向A‘的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。
这时候，从库B的同步线程就会报告 Duplicate entry 'id_of_R' for key 'PRIMARY' 错误，提示出了主键冲突，然后停止同步。

## GTID
那么，GTID到底是什么意思，又是如何解决找同步位点这个问题呢？
在GTID模式下，每个事务都会跟一个GTID

## 用动态的观点看加锁
**加锁规则，包含了两个"原则"、两个"优化"和一个"bug"**
- 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
- 原则2：查找过程中访问到的对象才会加锁。
- 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
- 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
- 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
有同学对 "等值查询" 提出了疑问：等值查询和 "遍历" 有什么区别？
要知道，加锁动作.

## 死锁的例子
```sql
begin;
select id from t where c in (5, 20, 10) lock in share mode;
```

```sql
select id from t where c in (5, 20, 10) order by c desc for update;
```
由于语句2里面是order by c desc，这三个记录锁的加锁顺序，是先锁c = 20，然后 c = 10，最后是c = 5。
也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。
这里，我们可以得到两个结论：
1. 由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；
2. 在发生死锁的时刻，for update这条语句占有的资源多，回滚成本更大，所以InnoDB选择了回滚成本更小的 lock in share mode语句，来回滚。

Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binglog_format=row 和 binlog_row_image=FULL。

具体恢复数据时，对单个事务做如下处理：
1. 对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；
2. 同理，对于delete语句，也是将Delete_rows event 改为 Write_rows event;
3. 而如果是 Update_rows 的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。

## 如果是truncate / drop删除表，因为没有记录binlog，所以需要通过全量备份加增量重放binlog的方式来恢复数据，恢复时需要注意如下细节：
1. 为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个--database参数，用来指定误删表所在的库。这样，就避免了再恢复数据时还要应用其他库日志的情况。
2. 在应用日志的时候，需要跳过12点误操作的那个语句的binlog：
	- 如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用 --stop-position 参数执行到误操作之前的日志，然后再用 --start-position 从误操作之后的日志继续执行；
	- 如果实例使用了GTID模式，就方便多了。假设误操作的GTID是 gtid1，那么只需要执行set gitd_next=gtid1;begin;commit;先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。
## 延迟复制备库
延迟复制的备库是一种特殊的备库，通过 `CHANGE MASTER TO MASTER_DELAY = N` 命令，可以指定这个备库持续保持跟主库有N秒的延迟。
比如你把N设置为3600秒，如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，通过GTID或者位点的方式跳过误操作的命令，就可以恢复出需要的数据。


为了让它得以运作，我必须把租期长度作为参数传递进去。当然，租期长度来自Rental对象。计算费用时需要两线