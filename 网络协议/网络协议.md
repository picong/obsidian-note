通过`ip addr`查看的网卡信息，得出以下知识点：
- IP是地址，有定位功能；MAC是身份证，无定位功能；
- CIDR可以用来判断是不是本地人
- IP分公有的IP和私有的IP。

## 如何实现一个靠谱的协议？
TCP协议为了保证顺序性，每个包都有一个ID。在建立连接的时候，会商定起始ID是什么，然后按照ID一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的ID，表示都收到了，这种模式称为 **累计确认** 或者 **累计应答(cumulative acknowledgement)**。
发送端和接收端都会使用缓存来分别记录发送的包和接收的包，发送端的缓存里是按照包的ID一个个排列，根据处理的情况分成四个部分。
- 第一部分：发送了并且已经确认的。
- 第二部分：发送了并且尚未确认的。
- 第三部分：没发送，但是已经等待发送的。
- 第四部分：没有发送，并且暂时还不会发送的。
在TCP中，接收端会给发送端汇报一个窗口的大小，叫**Advertised window**。超过这个窗口的，接收端处理不过来，发送端就不能再发送了。
![[Pasted image 20240621094241.png]]
- LastByteAcked：第一部分和第二部分的分界线
- LastByteSend：第二部分和第三部分的分界线
- LasteByteAcked + AdvertisedWindow：第三部分和第四部分的分界线

而对于接收端来讲，它的缓存记录的内容如下：
- 第一部分：接收并且确认过的。
- 第二部分：还没接收，但是马上就能接收的。
- 第三部分：还没接收，也没法接收的。
![[Pasted image 20240621094421.png]]
- MaxRcvBuffer：最大缓存的两；
- LastByteRead之后是已经接收了，但是还没被应用层读取的；
- NextByteExpected是第一部分和第二部分的分界线。
A = (NextByteExpected - 1) - LastByteRead;
AdvertisedWindow = MaxRcvBuffer - A;
第二部分和第三部分的分界线 = LastByteRead + MaxRcvBuffer.
## 顺序与丢包问题
超时重试：每一个发送的包但是没有ACK的包，都设定了一个定时器，定时器的时间一般要大于往返时间RTT，否则会引起不必要的重传。TCP需要通过采样RTT时间，然后进行加权平均计算出来一个值来估计往返时间，因为网络状况不断地变化，所以这个值也会变化，除了采样RTT，还要采样RTT的波动范围。由于重传时间是不断变化的，我们称为 **自适应重传算法(Adaptive Retransmission Algorithm)**。

有需要重传的时候，**TCP的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超市，就说明网路环境差，不宜频繁反复发送。**
有一个快速重传的机制，当接收方收到一个序号大于下一个期望的报文段时，就会检测到数据流中的一个间隔，于是它就回发送冗余的ACK，这个ACK是期望接收到的包的上一个包的应答。而当客户端收到三个冗余的ACK后，就会在定时器过期之前，重传丢失的报文段。

还有一种方式称为 **Selective Acknowledgement (SACK)**。这种方式需要在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方。
## 流量控制 VS 拥塞控制
流量控制和拥塞控制都是通过窗口的大小来控制，流量控制是用滑动窗口rwnd是怕发送方把接收方缓存塞满，而拥塞窗口cwnd,是怕把网络塞满。
TCP的拥塞控制主要来避免的两个现象都是有问题的：
- **第一个问题** 是包丢了并不代表这通道满了。
- **第二个问题** 是TCP的拥塞控制要等到将中间设备都填满了，才发生丢包，从而降低速度，这时候已经晚了。
为了优化这两个问题，后来有了**TCP BBR拥塞算法。** 它企图找到一个平衡点，就是通过不断地加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。

流量控制有两种方式，一种是基于发送速率的流量控制，发送端设定一个确定的允许发送的速率，保证发送的速率一定不会超过这个发送速率。这种流量控制的方式最适合流式应用以及可以用于广播和多播分发。(rate-based)
另一种流量控制方式是，是使用最广泛的流量控制，这种流量控制窗口的大小不是固定的，这种情况下接收者必须通过ACK来通知发送者应该使用多大的窗口。这个窗口大小通常被称为 `window advertisement` 或者 简单的叫做 `window update`。(window-based)
流量控制是假设网络情况良好的情况下的，但现实是网络上路由器等这些设备也有可能存在瓶颈，所以只进行流量控制是不行的，所以就有拥塞控制。(congestion control)
## TCP 建立连接为什么需要三次握手
![[Pasted image 20240625112936.png]]
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！
**TCP可靠传输的精髓：** TCP连接的一方A，由操作系统动态随机选取一个**32位长的序列号(Initial Sequence Number),** 假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001,1002,1003...，并把自己的初始化序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B可以A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。同理B的操作类似。
**一句话概括，TCP连接握手，握的是啥？**
**通信双方数据原点的序列号！**
## 四次握手的过程：
1. A发送同步信号SYN + A's Initial sequence number
2. B确认收到A的同步信号，并记录A's ISN到本地，命名 B's ACK sequence number
3. B发送同步信号SYN + B's Initial sequence number
4. A确认收到B的同步信号，并记录B's ISN到本地，命名A's ACK sequence number
很显然2和3这两个步骤可以合并，**只需要三次握手**，可以提高连接的速度与效率。
## 二次握手的过程
1. A 发送同步信号SYN + A's ISN
2. B发送同步信号SYN + B's ISN + B's ACK sequence number
这里有一个问题，A与B就A的的初始序号达成了一致，这里是1000.但是B无法知道A是否已经连接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。
于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号 (FIN标志位也是)，既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。
**TCP不会为没有数据的ACK超时重传。**
**所以，B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。**
```ad-summary
**第一个包，即A发给B的SYN中途被丢，没有到达B**
A会周期性超时重传，直到收到B的确认或者重传次数已经达到上限。
**第二个包，即B发给A的SYN + ACK中途被丢，没有到达A**
B会周期性超时重传，直到收到A的确认或者重传次数已达上限。
**第三个包，即A发给B的ACK中途被丢，没有到达B**
A发送完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态：
a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接也为Establised状态，双向可以发包
b. 假定此时A有数据发送，B收到A的data + ACK，自然会切换为established状态，并接受A的data。
c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。
```
## 为什么需要四次挥手？
![[Pasted image 20240625112916.png]]
TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传输结束后发粗连接释放的通知，待对方确认进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放的通知，对方确认后就完全关闭了TCP连接。
## 为什么第四次挥手客户端需要等待`2*MSL`(报文段最长寿命) 时间后才进入Closed状态？
第四次挥手时，客户端发送给服务端的ACK有可能丢失，如果服务端因为某些原因而没有收到ACK的话，服务端就回重发FIN，如果客户端在`2*MSL`的时间收到了FIN，就回重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。
> MSL(Maximum Segment Lifetime): 一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需要的最大时间。如果知道2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
