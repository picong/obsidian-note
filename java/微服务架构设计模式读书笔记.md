## 第一章小结
- 单体架构模式将应用程序构建为单个可部署单元。
- 微服务脚骨模式将系统分解为一组可独立部署的服务，每个服务都有自己的数据库。
- 单体架构是简单应用的不错选择，微服务架构通常是大型复杂应用的更好选择。
- 微服务架构使小型自治团队能够并行工作，从而加快软件开发的速度。
- 微服务架构不是银弹：它存在包括复杂性在内的诸多弊端。
- 微服务架构模式语言是一组模式，可帮助你使用微服务架构构建应用程序。它可以帮助你决定是否使用微服务架构，如果你选择微服务架构，模式语言可以帮助你有效地应用它。
- 你需要的不仅仅是通过微服务架构来快速软件交付。成功的软件开发还需要DevOps和小而自治的团队。
- 不要忘记采纳微服务过程中的人性层面。你需要考虑员工的情绪才能成功转换到微服务架构。
## 什么是软件架构
计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。--- Bass等 《Documenting Software Architectures：Views and Beyond》。
上述定义是个非常抽象的定义，其实本质是应用程序的架构是将软件分解为元素和这些元素之间的关系。

## 软件架构的4+1视图模型
![[Pasted image 20250612111939.png]]
**架构的重要性在于**，它帮助应用程序满足了**非功能性需求**。这类需求被称之为质量属性需求。这些非功能呢性需求决定一个应用程序在运行时的质量，比如扩展性和可靠性。也决定了开发阶段的质量，包括可维护性、可测试性、可扩展性和可补属性。

## 分层架构风格
架构风格的典型例子是分层架构。分层架构将软件元素按"层"的方式组织。每个层都有明确定义的职责。分层架构还限制了层之间的依赖关系。每一层只能依赖于紧邻其下方的层(如果严格分层)或其下面的任何层。

流行的三层架构是应用于逻辑视图的分层架构。它将应用程序的类组织到一下层中：
- 表现层
- 业务逻辑层
- 数据持久层
分层架构的弊端：
- 单个表现层
- 单一数据持久层
- 将业务逻辑层定义为依赖于数据持久化层：理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑。
## 六边形架构风格
六边形架构选择以业务逻辑为中心的方式组织逻辑视图。应用程序具有一个或多个**入站适配器**，而不是表示层，它通过调用业务逻辑来处理来自外部的请求。同样，应用程序具有一个或多个**出站适配器**，而不是数据持久层，这些出站适配器由业务逻辑调用并调用外部应用程序。此架构的一个关键特性和优点是业务逻辑不依赖于适配器。
![[Pasted image 20250612134019.png]]
六边形架构风格的一个重要好处是它将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开来。业务逻辑不依赖于表示层逻辑或数据访问层逻辑。
## 微服务架构风格
### 服务定义：服务是一个单一的、可独立部署的软件组件。
### 松耦合： 微服务架构的核心特性是服务间的松耦合性。服务之间交互采用API完成，这样做就封装了服务的实现细节。
### 共享类库的角色：可能会更改的通用功能作为服务来实现，每个服务都通用的实现应该创建一个供所有服务使用的共享库。
### 服务的大小并不重要

## 为应用定义微服务架构
### 识别系统操作
第一步创建有由关键类组成的抽象领域模型，这些关键类提供用于描述系统操作的词汇表。第二步确定系统操作，并根据领域模型描述每个系统操作的行为。
![[Pasted image 20250612145851.png]]
领域模型主要源自用户故事中提及的名词，系统操作主要来自用户故事中提及的动词。
### 创建抽象领域模型
### 定义系统操作
有以下两种类型的系统操作：
- **命令型**：创建、更新或删除数据的系统操作。
- **查询型**：查询和读取数据的系统操作。
### 根据业务能力进行服务拆分，业务能力定义了一个组织的工作
- 识别业务能力
- 从业务能力到服务：决定将那个级别的能力层次结构映射到服务是一个非常主观的判断。
## 根据子域进行服务拆分
领域驱动为每一个子域定义单独的领域模型。子域是领域的一部分，领域是DDD中用来描述应用程序问题域的一个术语。识别子域的方式跟识别业务能力一样。

DDD把领域模型的边界成为**限界上下文(bounded context)**。限界上下文包括实现这个模型的代码集合。当使用微服务脚骨时，每一个限界上下文对应一个或一组服务。换个说法，我们可以通过DDD的方式定义子域，并把子域对应为每一个服务，这样就完成了微服务架构的设计工作。
![[Pasted image 20250612154147.png]]
## 拆分指导原则（源自面向对象设计中的一些原则）
- 单一职责原则：设计小的、内聚的、仅仅含有单一职责的服务，会缩小服务的大小并提高它的稳定性。
- 闭包原则：在微服务架构下采用CCP原则，这样我们就能根据同样原因进行变化的服务放在一个组件内。这样做可以控制服务的数量，当需求发生变化时，变更和部署也更加容易。
## 拆分单体应用为服务的难点
- 网络延迟
- 同步进程间通信导致可用性降低
- 在服务之间维持数据一致性
- 获取一致的数据视图
- 上帝类阻碍了拆分
	 解决这个问题的方法是应用DDD并将每个服务视为具有自己的领域模型的单独子域。
## 定义服务API
- 把系统操作分配给服务
- 确定支持服务协作所需要的API
```ad-abstract
- 架构决定了软件的各种非功能性因素，比如可维护性、可测试性、可补属性和可扩展性，它们会直接影响开发速度。
- 微服务架构是一种架构风格，它给应用程序带来了更高的可维护性、可测试性、可部署性和可扩展性。
- 微服务中的服务是根据业务需求进行组织的，按照业务能力或者子域，而不是技术上的考量。
- 有两种分解模式：
	- 按业务能力分解
	- 基于领域驱动设计的概念，通过子域进行分解
- 可以通过应用DDD并为每个服务定义单独的领域模型来消除上帝类，正式上帝类引起了阻碍分解的脚趾依赖项。
```

## 服务发现
服务发现的关键是服务注册表，它是包含服务实例网络位置信息的一个数据库。
服务实例启动和停止时，服务发现机制会更新服务注册表。当客户端调用服务是，服务发现机制会查询服务注册表以获取可用服务实例的列表，并将请求路由到其中一个服务实例。
### **应用层服务发现**
![[Pasted image 20250613154908.png]]
### **平台层服务发现**
![[Pasted image 20250613154936.png]]
由平台提供服务发现机制的主要好处是服务发现的所有方面都完全由部署平台处理。服务和客户端都不包含任何服务发现代码。因此，无论使用哪种语言或框架，服务发现机制都可供所有服务和客户使用。
弊端是它仅限于支持使用该平台部署的服务，例如基于Kubernets的服务发现仅使用与Kubernetes上运行的服务。
## 使用消息机制实现交互方式
- 请求/响应和异步请求/响应
![[Pasted image 20250613155041.png]]
- 单向通知
- 发布/订阅
- 发布/异步响应: 这里需要解释一下，发布/异步响应式通过把发布/订阅和请求/响应这两种方式的元素组合在一起实现的。
## 处理并发和消息顺序
消息顺序和并发问题：
现代消息代理(如Kafka 和 AWS Kinesis) 使用的常见解决方案是使用分片通道。该解决方案分为三个部分，如下图所示：
1. 分片通道由两个或多个分片组成，每个分片的行为类似于一个通道。
2. 发送方在消息头部指定分片键，通常是任意字符串或字节序列。消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。
3. 消息代理将接收方的多个实例组合在一起，并将它们视为相同的逻辑接收方。例如，Kafka使用属于消费者组。消息代理将每个分片分配给单个接收器。它在接收方启动和关闭时重新分配分片。
![[Pasted image 20250613155148.png]]
这里根据orderId作为其分片键，特定订单的每个时间都发布到同一个分片，而且该分片中的消息始终由同一个接收方实例读取。因此，这样做就能够保证按顺序处理这些消息。
## 处理重复消息
## **编写幂等消息处理器**
如果应用程序处理消息的逻辑是满足幂等的，那么重复的消息就是无害的。
### **跟踪消息并丢弃重复消息**
一个简单的解决方案就是消息接收方使用 message id跟踪它已经处理的消息并丢弃任何重复项。如下图所示：
![[Pasted image 20250613155208.png]]
## 事务性消息
数据库更新和消息发送都必须在事务中进行。否则就有可能导致系统处于不一致的状态。
### **使用数据库表作为消息队列**
![[Pasted image 20250613155232.png]]
服务通过将消息作为更新数据库的事务的一部分插入到OUTBOX表中来可靠地发布消息。Message Relay读取OUTBOX表并将消息发布到消息代理。

将消息从数据库移动到消息代理并对外发送有两种不同的方法。
- 通过轮询模式发布事件 --- 定时任务轮询OUTBOX发送消息，发送成功后从OUTBOX中批量删除发送成功的记录。
- 使用事务日志拖尾模式发布事件 --- 可以通过监听数据库的事务日志来进行消息的发布，这样对数据库的性能影响小。例如监听mysql中binlog日志来发布消息。
![[Pasted image 20250613155351.png]]
日志拖尾方案有一些实际应用案例可供参考:
- Debezium
- LinkedIn Databus
- DynamoDB streams
- Eventuate Tram
## 使用异步消息提高可用性
- **使用异步交互模式**
![[Pasted image 20250613155439.png]]
- **复制数据**
![[Pasted image 20250613155457.png]]
- **先返回响应，再完成处理** -- 需要不同的状态来表示执行到哪一步了
![[Pasted image 20250613155513.png]]
```ad-summary
- 微服务架构是一种分布式架构，因此进程间通信起着关键作用。
- 仔细管理服务API的演化至关重要。向后兼容的更改是最容易进行的，因为它们不会影响客户端。如果对服务的API进行重大更改，通常需要同时支持旧版本和新版本，直到客户端升级为止。
- 有许多进程间通信技术，每种技术都有不同的利弊。一个关键的设计决策是选择同步远程过程调用模式或异步消息模式。基于同步远程过程调用的协议是最容易使用的。但是，理想情况下，服务应使用异步消息进行通信，以提高可用性。
- 为了防止故障通过系统层层蔓延，使用同步协议服务的客户端必须设计成能够处理局部故障，这些故障是在被调用的服务停机或表现出高延迟时发生的。特别是，它必须在发出请求时使用超时，限制未完成请求的数量，并使用断路器模式来避免调用失败的服务。
- 使用同步协议的架构必须包含服务发现机制，以便客户端确定服务实例的网路位置。最简单的方法是使用部署平台实现的服务发现机制：服务器端发现和第单方注册模式。但是另一种方法是在应用程序级别实现服务发现：客户端发现和自注册模式。它需要的工作量更大，但它确实可以处理服务在多个部署平台上运行的场景。
- 设计基于消息的架构的一种好方法是使用消息和通道模型，它抽象底层消息系统的细节。然后，你可以将该设计映射到特定消息基础结构，该基础结构通常基于消息代理。
- 使用消息机制的一个关键挑战是以原子化的方式完成数据库更新和发布消息。
```


## CQRS查询视图
- 实现从多个服务检索数据的查询具有挑战性，因为每个服务的数据都是私有的。
- 有两个方法可以实现这些类型的查询：API组合模式和命令查询职责隔离(CQRS)模式。
- 从多个服务获取数据的API组合模式是实现查询的最简单方法，应尽可能使用。
- API组合模式的局限性是某些复杂查询需要大型数据集的低效内存连接。
- 使用视图数据库实现查询的CQRS模式功能更强大，但实现起来更复杂。
- CQRS视图模块必须处理并发更新一集检测和丢弃重复事件。
- CQRS有助于改善问题隔离，服务不必为自己拥有的数据实现查询功能。
- 客户端必须处理CQRS视图的最终一致性。
## API Gateway
- 应用程序的外部客户端通常利用API Gateway访问应用程序的服务。API Gateway为每个客户端提供自定义API。它负责请求路由、API组合、协议转换以及边缘功能(如身份验证)的实现。
- 应用程序可以具有单个API Gateway，也可以使用后端前置模式，该模式为每种类型的客户端定义API Gateway。后端前置模式的主要优点是它为客户端团队提供了更大的自主权，因为他们可以开发、部署、运维自己的API Gateway。
- 可以使用多种技术来实现API Gateway，包括现成的API Gateway产品。或者你也可以使用框架开发自己的API Gateway。
- Spring Cloud Gateway是一个易于使用的良好框架，用于开发API Gateway。它使用任何属性(包括方法和路径)路由请求。Spring Cloud Gateway可以将请求直接路由到后端服务或自己定义处理程序方法。它采用可扩展、响应式的Spring Framework5和Project Reactor框架构建。你可以使用，例如，Project Reactor的Mono抽象，以响应式风格编写自定义请求处理程序。
- GraphQL是一个提供基于图形的查询语言框架，是开发API Gateway的另一个很好的基础。可以编写一个面向图形的模式来描述服务器端数据模型及其支持的查询。然后，通过编写检索数据的解析器，将该模式映射到你的服务。基于GraphQL的客户端对模式执行查询，该模式准确指定服务器应返回的数据。因此，基于GraphQL的API Gateway可以支持不同的客户端。

## 测试
消费者驱动的契约测试：验证服务是否满足它的消费者的期望。
消费者契约测试：验证服务的客户端是否可以与服务通信

### 但愿测试的类型
![[Pasted image 20250618174449.png]]
控制器和服务类通常使用独立型单元测试，领域对象(例如实体和值对象)通常使用协作型单元测试。
![[Pasted image 20250618174838.png]]
### 小结
- 自动化测试是快速、安全地交付软件的重要基石。更重要的是，由于微服务架构固有的复杂性，要从微服务架构中充分受益，必须实现自动化测试。
- 测试的目的是验证被测试系统(SUT)的行为。在这个定义中，系统是一个泛指，意味着被测试的软件元素。他可能像一个类一样小，也可能像整个应用程序一样大，或者是介于两者之间，例如一组类或一个单独的服务。测试套件是一组相关测试的集合。
- 简化和加快测试的一个好方法是使用测试替身。测试替身是一个模拟被测试系统依赖项的行为的对象。有两中类型的测试替身：桩和模拟。桩是一个测试替身，它将值返回给被测试系统。模拟也是一个测试替身，由测试用来验证被测试系统是否正确调用依赖。
- 测试金字塔可确定将测试重点放在服务的哪个部分。大多数测试应该是快速、可靠且易于编写的单元测试。必须尽量减少端到端测试的数量，因为它们写入速度慢、脆弱且耗时。
