## 除了Basic认证外，IETF还定义了很多种可用于实际生产环境的认证方案，比如：
- Digest：RFC7616，HTTP摘要认证，你可以把它看作是Basic认证的改良版本，针对Base64明文发送的风险，Digest认证把用户名和密码加盐 (一个被称为Nonce的变化值作为盐值)后，再通过MD5/SHA等哈希算法取摘要发送出去。**这种认证方式依然是不安全的**，无论客户端使用何种加密算法加密，无论是否采用了Nonce这样的动态盐值取抵御重放和冒认，当遇到中间人攻击时，依然存在显著的安全风险。
- Bearer: RFC 6750，基于OAuth2.0规范来完成认证，OAuth2.0是一个同时涉及到认证与授权的协议。
- HOBA: RFC 7486,HOBA 是 HTTP Origin-Bound Authentication 的缩写，这是一种基于自签名证书的认证方案。基于数字证书的信任关系主要有两类模型，一类是采用CA(Certification Authority) 层次结构的模型，由CA中心签发证书；另一种是以IETF的Token Binding协议为基础的OBC(Origin Bound Certificates) 自签名证书模型。
许可其实抽象权限的具象化提现。权限在RBAC系统中的含义是“允许何种操作作用于哪些资源之上“，这句话的具体实例即为"许可"。
## RBAC 的概念间关系
在RBAC模型中，角色拥有许可的数量，是根据完成该角色工作职责所需的最小权限所赋予的。
需要记住以下几个核心要点：
- 所有的访问控制模型，实质上都是在解决同一个问题：谁(User) 拥有什么权限(Authority) 去操作 (Operation) 哪些资源 (Resource)。
- 为了避免度你每一个用户设定权限，RBAC提出了角色和许可等概念，角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系。
- 建立访问控制模型的基本目的就是为了管理垂直权限和水平权限。垂直权限即功能权限，水平权限则是数据权限，它很难抽象与通用。

## OAuth2.0的几种授权模式
**授权码模式：**
![[Pasted image 20240604100319.png]]

**隐式授权：**
隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端的支持，异步到位。
![[Pasted image 20240604101758.png]]
在这个交互过程里，**隐式模式与授权码模式的显著区别是授权服务器在得到用户授权后，直接返回了访问令牌，** 这很明显会降低授权的安全性。所以，基于安全考虑，在隐式模式中也明确禁止发放刷新令牌。
隐式授权巧妙地利用了，Fragment不会被浏览器通过Ajax请求被发送到服务端，只能在客户端通过Script脚本的读取的特性，尽最大努力地 **令牌从操作代理到第三方服务之间的链路，存在被攻击而泄露出去的可能性。**
至于认证服务器到操作代理之间的这一段链路的安全，则只能通过TLS(即HTTPS)来保证不会受到中间人攻击了，我们可以要求认证服务器必须都是启用HTTPS的，但无法要求第三方应用同样都支持HTTPS。

**密码模式**
授权码模式和隐式模式都属于纯粹的授权模式，它们和认证没有直接的联系。但是在密码模式里，认真和授权被整合到了一起。
![[Pasted image 20240604111733.png]]
但是在这种模式下面，要保证安全性，这里的第三方系统不能是外部的系统，必须是可以信任的系统内部的独立的模块，才有安全性的保障。

**客户端模式**
客户端模式就是指第三方应用以自己的名义，向授权服务器申请资源许可。**这种模式通常用于管理操作或者自动处理类型的场景中。**
![[Pasted image 20240604112358.png]]
微服务间的调用，一般采用这种模式。
在OAuth2.0中，还有一种与客户端模式类似的授权模式，在RFC 8628中定义为"**设备码模式(Device Code)**"。
![[Pasted image 20240604113015.png]]
总结：OAuth 2.0的核心思想是令牌代替密码。


