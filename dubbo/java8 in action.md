```ad-note
1. reducing收集器永远都不会返回Opional.empty();
```

## Collector接口的设计
```java
public interface Collector<T, A, R> {
	Supplier<A> supplier(); // 建立新的结果容器
	BiConsumer<A, T> accumulator(); // 将元素添加到结果容器
	Function<A, R> finisher(); // 对结果容器应用最终转换
	BinaryOperator<A> combiner(); // 合并两个结果容器
	Set<Characteristics> characteristics(); //告诉collect方法在执行规约操作的时候可以应用那些优化(如并行化)
}
```
本列表使用以下定义。
T 是流中要收集的数据的泛型。
A 是累加器的类型，累加器是在收集过程中用于累计部分结果的对象。
R 是收集操作得到的对象 （通常但并不一定是集合）的类型。

## 第7章 并行数据处理与性能
```ad-abstract
用并行流并行处理数据
并行流的性能分析
分支/合并框架
使用Spliterator分割流
```

## Optional类的使用
变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty() 返回。
![[Pasted image 20230919181624.png]]
可以通过flatMap扁平化Optional`<Optional<Object>>` 到一个`Optional<Object>`中。

## 新的日期和时间API

### 为什么在Java 8中需要引入新的日期和时间库
1. `Date`类的其实年份选择是1900，月份的起始是0，而`Calendar`类的这几虽然去掉了由1900年开始计算年份这一设计，但是月份依旧是从0开始计算。然后Date和Calendar类都是可以变的。能把2017年9月21日修改成10月25日。
2. `DateFormat`不是线程安全的。

### Java 8之后将oracle将joda time中的一些特性整合进JDK中
1. `LocalDate` 表日期，`LocalTime` 表时间，`LocalDateTime` 表示日期加时间。
2. 可以通过实现`TemporalAdjuster`接口来实现个性化的日期调整方案，再向`Temporal.with`中传入该调整方案对指定日期进行调整，注意Temporal实例都是不可变的，每次调整都会创建副本对象返回，`TemporalAdjusters`提供了许多工具方法，为我们创建一些非常有用的调整方案。
### 日期格式化
通过使用`DateTimeFormatter` 来格式化日期以及解析日期重建LocalDate以及LocalDateTimeo.

```ad-note
可以通过Date的toInstant和fromInstant来和Instant进行互相转换，
而LocalDateTime和Instant也可以通过LocalDateTime的ofInstant方法和toInstant方法进行相互转换
```
### 处理不同的时区和历法
1. ZoneId.of方法可以创建ZoneId对象，一旦得到一个ZoneId对象，就可以将它与LocalDate、LocalDateTime或者是Instant对象整合起来，构造一个ZonedDateTime实例，它代表了相对于指定时区的时间点。
2. 利用和UTC/格林尼治时间的固定偏差计算时区: 


## Java9 模块化
### requires
requires子句可以在编译和运行时帮你设定你的模块对另一模块的依赖。
### exports
exports子句可以将某些包声明为共有类型，提供给其他的模块使用。
```ad-note
requires后面跟的是模块名，exports后面跟的是包名
```
### requires transitive
我们可以声明一个模块能够使用另一个模块依赖的公有类型的包。
```java
module com.iteratrlearning.ui {    
requires transitive com.iteratrlearning.core;    
exports com.iteratrlearning.ui.panels;    
exports com.iteratrlearning.ui.widgets;
}
module com.iteratrlearning.application {    
requires com.iteratrlearning.ui;
}
```
通过requires transitive可以在application模块中自动引入com.iteratrlearning.core模块。
### exports to 
通过exports to子句，可以控制哪些用户可以访问哪些导出的包。

### open 和 opens
模块声明中使用open限定符能够让其他模块以反射的方式访问它所有的包。

# Chapter 16 CompletableFuture：**组合式异步编程**
## 建议：
如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程）。
反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，一句等待/计算,后者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底是什么时候触发了等待。

### CompletableFuture#thenApply
当CompletableFuture最终结束时，希望传递Lambda表达式给thenApply方法，将Stream中的每个CompletableFuture作为参数调用lambda函数进行预期的操作。
```java
CompletableFuture<Integer> finalResult = compute().thenApply(s-> s + 1);
```

### CompletableFuture#thenCompose
该方法允许你对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作jj。
```java
CompletableFuture<Integer> computeAnother(Integer i){
    return CompletableFuture.supplyAsync(() -> 10 + i);
}
CompletableFuture<Integer> finalResult = compute().thenCompose(this::computeAnother);
```
```ad-note
如果需要连接多个CompletableFutue，进行流水线工作(前面的任务完成才能开始thenCompose中的任务)，请使用thenCompose方法，如果只是连接最终结果请使用thenApply方法。

如果你需要将两个完全不相干的CompletableFuture对象整合起来而且你也不希望等到第一个任务完全结束才开始第二个任务,这种情况应该使用thenCombine方法。

```

## 总结
执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，使用异步任务可以改善程序的性能，加快程序的响应速度。
你应该尽可能地为客户提供异步API。使用CompletableFuture类提供的特性，你能够轻松地实现这一目标。
`CompletableFuture`类还提供了异常管理的机制，让你有机会抛出/管理异步任务执行中发生的异常。
将同步API的调用封装到一个CompletableFuture中，你能够以异步的方式使用其结果。
如果异步任务之间相互独立，或者它们之间某一些的结果是另一些的输入，那么你可以将这些异步任务构造或者合并成一个。
你可以为CompletableFuture注册一个回调函数，在Future执行完毕或者它们的计算结果可用时，针对性地执行一些程序。
你可以决定在什么时候结束程序的运行，是等待由CompletableFuture对象构成的列表中所有的对象都执行完毕，还是只要其中任何一个首先完成就终止程序的运行。
Java 9通过orTimeout和completableOnTimeout方法为CompletableFuture增加了对异步超时机制的支持。

# 第17章 反应式编程
## 反应式的四个特征
- **响应性** --顾名思义，反应式系统的响应时间很快，更重要的是它的响应时间应该是稳定且可预测的。只有这样，用户才能明确地设定他的预期。而这反过来又会增强用户的信息，是应用易用性的关键指标。
- **韧性** --系统在出现失败时依然能继续响应服务。为了构建弹性的应用，反应式宣言提供了一系列的建议，包括组件运行时复制，从时间（发送方和接收方都拥有相互独立的生命周期）和空间（发送方和接收方运行于不同的进程）维度对组件进行解耦，从而使任何一个组件都能以异步的方式向其他组件分发任务。
- **弹性** --影响应用响应性的另一个重要因素是应用的工作负载。应用生命周期中不可避免地会遭遇各种规模的负载。反应式系统在设计时就需要考虑这一点，增加分配的资源后，受影响的组件要有能力自动地适配和服务更大的负荷。
- **消息驱动** --韧性和弹性要求明确定义构成系统的组件之间的边界，从而确保组件之间的松耦合、组件隔离以及位置透明性。跨组件通信则通过异步消息传递。这种设计既实现了韧性（以消息传递组件失败）又确保了弹性（通过监控交换消息规模的变化，适时调整资源分配，从而实现资源配置的优化，满足业务的需求）

实际上，这个接口反映的就是反应式流中事件的转化阶段。接收到错误时，Processor可以选择从出错状态恢复（接着需要将该Subscription设置为取消状态），或者直接向Subscriber抛出onError信号。当最后一个Subscriber取消

# 第18章：函数式编程
```ad-tip
耦合性：软件系统中各组件之间是否相互独立
内聚性：系统各相关部分之间如何协作
```

## 什么是函数式编程
它是一种使用函数进行编程的方式。那么什么是函数呢？
当谈论**函数式** 时，我们想说的其实是“像数学函数那样 --- 没有副作用”。

### 函数式和局部函数式
在数学中，虽然合法的数学函数为每个合法的参数值返回一个确定的结果，但是很多通用的数学操作在严格意义上称之为局部函数式（partial function) 可能更为妥当。以Java那样抛出一个异常的方式对这些情况进行建模看起来非常自然。

### 引用透明性
### 面向对象的编程和函数式编程的对比

### 尾调优化（tail-call optimization)
这种形式的递归是非常有意义的，现在我们不需要再不同的栈帧上保存每次递归计算的中间值，编译器能够自行决定复用某个栈帧进行计算。实际上，在factorialHelper的定义中，立即数（阶乘计算的中间结果）直接作为参数传递给了该方法。再也不用为每个递归调用分配单独的栈帧用于跟踪每次递归调用的中间值---通过方法的参数能够直接访问这些值。
坏消息是，目前Java还不支持这种优化。但是使用相对于传统的递归，“尾-递”可能是更好的一种方式，因为它为最终实现编译器优化开启了一扇门。
### 小结
从长远看，减少共享可变数据结构能帮助你降低维护和调试程序的代价。
函数式编程支持无副作用的方法和声明式编程。
函数式方法可以由它的输入参数及输出结果进行判断。
如果一个函数使用相同的参数值调用，总是返回相同的结果，那么它是引用透明的。采用递归可以取代迭代式的结构，比如while循环。
相对于Java语言中传统的递归，“尾-递”可能是一种更好的方式，它开启了一扇门，让我们有机会最终使用编译器进行优化。

# 第19章 函数式编程的技巧
```ad-abstract
一等成员、高阶方法、柯里化以及局部应用
持久化数据结构
生成Java Stream时的延迟计算和延迟列表
模式匹配以及如何在Java中应用
引用透明性和缓存
```
第18章中使用术语函数式编程意指函数或者方法的行为应该像“数学函数”一样---没有副作用。对使用函数式语言的程序员而言，这个术语的范畴更加宽泛，它还意味着函数可以像任何其他值一样随便使用：可以作为参数传递，可以作为返回值，还能存储在数据结构中。能够想普通变量一样使用的函数被称为一等函数（first-class function）。这是Java 8 补充的全新内容：通过::操作符，你可以创建一个方法引用，像使用函数值一样使用方法，也能使用Lambda表达式(比如(int x) -> x + 1) 直接表示方法的值。

### 可以称为高阶函数的必要条件
- 接受至少一个函数作为参数
- 返回的结果是一个函数
	**副作用和高阶函数**
	第7章中我们了解到传递给流的函数应该是无副作用的，否则会发生各种各样的问题(比如错误的结果，有时由于竞态条件甚至会产生无法预期的结果)。这一原则在你使用高阶函数时也同样试用。编写高阶函数或者方法时，你无法预知会接收什么样的参数--- 一旦传入的参数又某些副作用，我们将会一筹莫展! 如果作为参数传入的函数可能对你程序的状态产生某些无法预期的改变，一旦发生问题，你将很难理解程序中发生了什么；它们甚至会用某种难于调试的方式调用你的代码。因此，将所有你愿意接受的作为参数的函数可能带来的副作用以文档的方式记录下来是一个不错的设计原则，最理想的情况下你接收的函数参数应该没有任何副作用！

### 柯里化的理论定义
**柯里化** 是一种将具备两个参数(比如，x 和 y) 的函数f转化为使用一个参数的函数g，并且这个函数的返回值也是一个函数（这个函数接收一其中一个参数），另一个参数会作为新函数的一个参数。后者的返回值和初始函数的返回值相同，即f(x,y) = (g(x))(y)。
当然，这个定义是一种概述。你可以将一个使用了六个参数的函数柯里化成一个接收第2、4、6号参数，并返回一个接收5号函数的函数，这个函数又返回一个接收剩下的第1号和第3号参数的函数。
当一个函数使用的所有参数仅有部分（少于函数的完整参数列表）被传递时，通常我们说这个函数是部分求值(partially applied) 的。
### Stream的延迟计算
通过前一章的介绍，你已经了解Stream是处理数据集合的利器。不过，由于各种各样的原因，包括实现时的效率考量，Java8的设计者们在将Stream引入时采用了比较特殊的方式。一个比较显著的局限是，你无法声明一个递归的Stream，因为Stream仅能使用一次。接下来的一节会详细展开介绍这一局限带来的问题。
在Java语言中，你执行一次方法调用时，传递的所有参数在第一时间会被立即计算出来。但是，在Scala中，通过`#::`操作符，连接操作会立刻返回，而元素的计算会推迟到实际计算需要的时候才开始。

### 创建你自己的延迟列表
你可以将一个函数作为值放置到某个数据结构中，大多数时候它就静静地待在那里，一旦对其进行调用（即根据需要），它能够创建更多的数据结构。

## 小结
一等函数是可以作为参数传递，可以作为结果返回，同时还能存储在数据结构中的函数。
高阶函数接受至少一个或者多个函数作为输入参数，或者返回另一个函数的函数。Java中典型的高阶函数包括comparing、andThen和compose
柯里化是一种帮助你模块化函数的重用代码的技术。

```ad-note
**闭包** 是一个函数实例，它可以不受限制地访问该函数的非本地变量。
```
