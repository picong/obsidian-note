# 1.1 计算机网络、分组报文和协议
计算机网络由一组通过通信信道相互连接的机器组成。对通信信道(communication channel) 进行解释：它是将字节序列从一个主机传输到另一个主机的一种手段，可能是有线电缆，如以太网(Ethernet)，也可能是无线的，如WiFi，或是其他方式的连接。
协议 (protocol) 相当于相互通信的程序间达成的一种约定，它规定了分组报文的交换方式和它们包含的意义。
应用程序通过套接字API对UDP协议和TCP协议锁提供的服务进行访问。
实际上，由一个程序写入的文件再由另一个程序读取就是一个TCP连接的适当模型。另一方面，UDP协议并不尝试对IP层产生的错误进行修复，它仅仅简单地扩展IP协议 “尽力而为” 的数据报服务，使它能够在应用程序之间工作，而不是在主机之间工作。因此，使用UDP协议的应用程序必须为处理报文丢失、顺序混乱等问题做好准备。

## 1.5 什么是套接字
socket (套接字) 是一种抽象层，应用程序通过它来发送和接收数据，就像应用程序打开了一个文件句柄，将数据读写到稳定的存储器上一样。
不同类型的socket与不同类型的底层协议族以及同一协议族中的不同协议栈相关联，本书只涵盖了TCP/IP协议族的内容。现在TCP/IP协议族中的主要socket类型为套接字(stream socket) 和数据报套接字 (datagram socket)。流套接字将TCP作为其端对端协议 (底层使用IP协议)，提供一个可信赖的字节流服务。
值得注意的是一个套接字抽象层可以被多个应用程序引用。每个使用了特定套接字的程序都可以通过那个套接字进行通信。

## 2.2 TCP套接字
Java为TCP协议提供了两个类：Socket类和ServerSocket类。一个Socket实例代表了TCP连接的一端。一个TCP连接是一条抽象的双向信道，两端分别由IP地址和端口号确定。在开始通信之前，要建立一个TCP连接，这需要先由客户端TCP向服务端TCP发送连接请求。ServerSocket实例则监听TCP连接请求，并为每个请求创建新的Socket实例。也就是说，服务器端要同时处理ServerSocket实例和Socket实例，而客户端只需要使用Socket实例。
```ad-note
注意：默认情况下，Socket是在TCP连接的基础上实现的，但是在Java中，你可以改变Socket的底层连接。
```

典型的TCP服务器执行如下两步工作：
1. 创建一个ServerSocket实例并指定本地端口。此套接字的功能是监听该指定端口收到的链接。
2. 重复执行：
	 - 调用ServerSocket的accept() 方法以获取下一个客户端连接。基于新建立的客户端连接，创建一个Socket实例，并有accept()方法返回。
	 - 使用所返回的Socket实例的InputStream和OutputStream与客户端进行通信。
	 - 通信完成后，使用Socket类的close() 方法关闭该客户端套接字连接。
  `ServerSocke` 实例的唯一目的，是为新的TCP连接请求提供一个新的链接的Socket实例。一个TCP终端必须与特定的端口号关联，以使客户端能够想该端口号发送连接请求。
## 2.3 UDP套接字
实际上UDP协议只实现两个功能：
1. 在IP协议的基础上添加了另一层地址 (端口)
2. 对数据传输过程中可能产生的数据错误进行检测，并抛弃已经损坏的数据。
客户端和服务端都使用DatagramSocket来发送数据，使用DatagramPacket来接收数据。
## 2.3.2 UDP客户端
一个典型的UDP客户端主要执行以下三步：
1. 创建DatagramSocket实例，可以选择对本地地址和端口号进行设置。
2. 使用DatagramSocket类的send() 和 receive() 方法来发送和接收DatagramPacket实例，进行通信。
3. 通信完成后，使用DatagramSocket类的close()方法来销毁该套接字。

## 发送和接收数据
对于任何多字节的整数，发送者和接受者必须在使用big-endian(大端)顺序还是使用little-endian(小端)顺序上打成共识。发送和接收者还需要打成的共识是：所传输的数值是有符号的(signed)还是无符号(unsigned)。
## 基本整型
构建java中原始数据类型的传输编码和解码的一个相对简单的方法是使用DataOutputStream类和ByteArrayOutputStream类。DataOutputStream类允许你将基本数据类型，如上述整型，写入一个流中：它提供了writeByte()、writeShort()、writeInt()、以及writeLong() 方法，这些方法按照big-endian顺序，将整数以适当大小的二进制补码的形式写入到流中。
## 字符串和文本
ASCII码将英语字母、数字、标点符号以及一些特殊符号(不可打印字符)映射成0~127的整数。
Java使用了一种称为Unicode的国际标准编码字符集来表示char型和String型值。Unicode字符集将 "世界上大部分的语言和符号" 映射到整数0~65535之间。Unicode包含了ASCII码，也就是为ASCII与Unicode之间提供了一定程度的向后兼容性。

发送者和接受者必须在符号与整数的映射方式上达成共识，才能使用文本信息进行通信。对于每个整数值都比255小的一小组字符，则不需要其他信息，因为其每个字符都能够作为一个单独的字节进行编码。
对于可能使用超过一个字节的大整数的编码方式，就有很多种方式在线路上对其进行编码。因此，发送者和接收者还需要对这些整数如何表示成字节序列统一意见，即编码方案 (encoding schema)。**编码字符集和字符的编码方案结合起来称为字符集(charset, 见RFC 2278)。**

Java提供了对任意字符集的支持，而且每种实现都必须支持以下至少一种字符集：US-ASCII，ISO-8859-1、UTF-8、UTF-16BE、UTF-16LE、UTF-16。

## 位操作：布尔值编码
位图 (Bitmaps) 是对布尔信息进行编码的一种非常紧凑的方式，通常用在协议中。位图的主要思想是整型数据中的每一位都能够一个布尔值编码 --- 通常0表示false，1表示true。要操纵位图，你需要了解如何使用Java中的 "位操作" 方法来设置和清除单独的一位。掩码 (mask) 是一个整数值，其中有一位或多位被设为1，其他各位被清空 (即，设为0)。在这里我们处理的是int大小的位图和掩码 (32位)，但这些方法对其他类型整数也同样适用。

## 组合输入输出流
![[Pasted image 20231110174715.png]]

## 成帧与解析
当然，将数据转换成在线路上传输的格式只完成一半工作，在接收端还必须将接收到的字节序列还原成原始信息。应用程序协议通常处理的是由一组字段组成的离散信息。
如果接收者试图从TCP套接字中读取比消息本身更多的字节，将可能发生以下两种情况：如果信道中没有其他消息，接受者将阻塞等待，同时无法处理接收到的消息；如果发送者也在等待接收端的响应消息，则会形成死锁 (deadlock); 另一方面，如果信道中还有其他消息，则接收者会将后面消息的一部分甚至全部读到第一条消息中去，这就产生一些协议错误。(粘包半包现象), 因此在使用TCP套接字时，成帧就是一个非常重要的考虑因素。(UDP的DatagramPacket负载的数据有一个确定的长度，所以UDP不会出现粘包半包现象)
我们首先要定位消息的结束位置。
主要有两个技术使接收者能够准确地找到消息的结束位置。
- 基于定界符 (Delimiter-based): 消息的结束由一个唯一的标记 (unique marker) 指出，即发送者在传输完数据后显示添加的一个特殊字节序列。这个特殊标记不能再传输的数据中出现。
- 显示长度 (Explicit length): 在边长字段或消息前附加一个固定大小的字段，用来指示该字段或消息中包含了多少字节。

## 多接收者
如果我们想要以固定频率发送数据，网络连接带宽就已经限制了其所能支持的接收者数量。幸运的是网络提供了更有效地使用带宽的方法。我们以将复制数据包的工作交给网络来做，而不是由发送者负责。
- 广播(broadcast)，(本地) 网络中的所有主机都会接收到一份数据副本。
- 多播(multicast),消息只是发送给一个多播地址(multicast address), 网络只是将数据分发给那些表示想要接收发送到该多播地址的数据的主机。总的来说，只有UDP套接字允许广播或多播。IP协议的设计者为多播分配了一定范围的地址空间，IPV4中的多播地址范围是224.0.0.0到239.255.255.255,IPV6中的多播地址是任何由FF开头的地址。

## 关闭连接
Socket类的shutdownInput()和shutdownOutput() 方法能够将输入输出流相互独立的关闭。

## 与Buffer一起使用Channel
如前文所述，Channel实例代表了一个与设备的链接，通过它可以进行输入输出操作。实际上Channel的基本思想与我们见过的普通套接字非常类似。对于TCP协议，可以使用ServerSocketChannel和SocketChannel。还有一些针对其他设备其他类型信道(如FileChannel), 尽管我们在后文中不会提及，这里介绍的大部分内容对于它们同样适用。信道(channel)和套接字(socket)之间的不通电之一，可能是信道通常要调用静态工厂方法来获取实例：
```java
SocketChannel clntChan = SocketChannel.open();
ServerSocketChannel sevChan = ServerSocketChannel.open();
```
Channel使用的不是流，而是缓冲区来发送或读取数据。Buffer类或其任何子类实例都可以看做是一个定长的Java基本数据类型元素序列。

## Selector
选择器就是一个多路开关选择器，因为一个选择器能够管理多个信道上的I/O操作。
下面来看一个例子。假设我们想要使用信道和选择器来实现一个回显服务器，

## TCP 连接
TCP的开放握手也称为3次握手(3-way handshake),因为这通常包括3条消息：一条从客户端到服务器端的连接请求，一条从服务器端到客户端的确认消息，以及另一条从客户端到服务器端的确认消息。
- 客户端
在初始的握手消息发送之后，并在接收到服务器端的回复消息之前，客户端主机上netstat的输出状态为SYN_SENT。客户端收到服务器端的肯定回复后，其状态转变为ESTABLISHED。
- 服务端
套接字的状态设置为"LISTENING",指示该套接字已经准备好接收传入该端口的连接请求。

当客户端的连接请求到来时，将为该连接创建一个新的套接字数据结构。新套接字的地址根据到来的分组报文设置：分组报文的目标互联网地址和端口号(分别为W.X.Y.Z和Q)称为该套接字的本地互联网地址和端口号；而分组报文的源地址和端口号(分别为A.B.C.D和P)则称为该套接字的远程地址和端口号。注意，新套接字的本地端口号总是与ServerSocket的端口号一致。
这里有非常重要的一点需要注意，在ServerSocket关联的列表中的每个数据结构，都代表了一个与另一端的客户端已经完成建立的TCP连接。实际上，客户端只要接收到了开放握手的第2条消息，就可以立即发送数据--这可能比服务器调用accept()方法为其获取一个Socket实例要早很长时间。
## TCP关闭连接
关闭握手消息已经发送，套接字数据结构的状态也已经设置为 "Closing" (专业术语称为 "FIN_WAIT_1"), 然后close()调用返回。完成这些工作后，将禁止在该Socket上的任何读写操作(会抛出异常)。当收到关闭握手确认消息后，套接字数据结构的状态则改变为 "半关闭" (专业术语称为 "FIN_WAIT_2")，这种状态将一直持续，直到接收到另一端的关闭握手消息。
注意，如果连接处于半关闭状态时，远程终端已经离开，那么本地底层数据结构则将无限期地保持在该状态。当另一端的关闭握手消息达到后，则发回一条确认消息并将状态改变为 "Time-Wait"。虽然应用程序中相应的Socket实例可能早已消失，与之关联底层数据结构还将在底层实现中继续存留几分钟。
**为什么要有一个套接字在Time-Wait转台保持一段时间**: 如果tcp两端完成关闭握手后，它们都移除了其底层数据结构，而此时在同样一对套接字地址之间又立即建立了新的连接，那么前一个连接在网络上传输时延迟的消息就可能在新连接建立后达到。（数据就可能被错误的分配到应用程序中）。
Time-Wait状态最重要的作用是，只要底层套接字数据结构还存在，就不允许在相同的本地端口上关联其他套接字。尤其是视图使用该端口创建新的Socket实例时，将抛出IOException异常。
## 解调多路复用
即同一个机器上的不同套接字可以有相同的本地地址和端口号。例如，在只有一个IP地址的机器上，每个通过ServerSocket的accept() 方法接收的新Socket实例都将使用与ServerSocket相同的本地端口号。显然，要确定传入的分组报文应该分配到哪个套接字(即，解调多路复用)不仅仅是查看分组报文的目的地址和端口。
对于TCP和UDP来说，将传入的分组报文匹配到某个套接字的过程是一样的，可以归纳为以下几点：
- 套接字数据结构中的本地端口号必须与传入的分组报文的目的端口号相匹配。
- 在套接字数据结构中，任何包含了通配符(`*`)的字段可以匹配分组报文中相应字段的任何值。
- 如果有一个以上的套接字数据结构与传入的分组报文地址的4个字段匹配，那么谁使用的通配符少，谁就获得该分组。

如果新的客户端试图使用同样的本地端口号，而由于其他数据结构正处于Time-Wait状态，Socket构造函数将抛出IOException异常。
本地地址或端口号可能会在构造函数中指定，否则，本地地址就使用