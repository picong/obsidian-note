
[[内存知识.pdf]]

为了让它得以运作，我必须把租期长度作为参数传递进去。当然，租期长度来自Rental对象。计算费用时需要两项数据：租期长度和影片类型。为什么我选择将租期长度传给Movie对象，而不是将影片类型传给Rental对象呢？因为本系统可能发生的变化是加入新影片类型，这种变化带有不稳定倾向。如果影片类型有所变化，我希望尽量控制它造成的影响，所以选择在Movie对象内计算费用。

我把上述计算方法放进Movie类，然后修改Rental的getCharge()，让它使用这个新函数 (图1-12和图1-13):


一般而言，重构都是对软件的小改动，但重构之中还可以包含另一个重构。例如Extract Class 通常包含Move Method和Move Field。
"重构" 的另一个用法是动词形式。

**重构**(动词): 使用一系列重构手法，在不改变软件观察行为的前提下，调整其结构。
所以，在软件开发过程中，你可能会花上数小时进行重构，期间可能用上数十种重构手法。
## 为何重构
- 重构改进软件设计
如果消除重复代码，你就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。
- 重构使软件更容易理解
- 重构帮助找到bug
- 重构提高编程速度


## 2.5 重构的难题
学习一种可以大幅提高生产力的新技术时，你总是难以察觉其不适用的场合。通常你再一个特定场景中学习它，这个场景往往是个项目。这种情况你很难看出什么灰造成这种新技术成效不彰甚或形成危害。十年前，对象技术的情况也是如此。

你无需一开始就插入分隔层，可以在发现对象模型变得不稳定时再产生它，这样你就可以为你的改变找到最好的平衡点。

**允许逻辑共享**。比如说一个子函数在两个不同的地点被调用，或超类中的某个函数被所有子类共享。
**分开解释意图和实现**。你可以选择每个类和函数的名字，这给了你一个解释自己意图的机会。类或函数内部则解释实现这个意图的做法。如果类

**封装条件逻辑**。对象有一种其妙的机制：多态消息，可以灵活而清晰地表达条件逻辑。将条件逻辑转化为消息形式，往往能降低代码的重复、增加清晰度并提高弹性。

这就是重构游戏：在保持系统现有行为的前提下，如何才能提高系统的质量或降低其成本，从而使它更有价值？
这个游戏中最常见的变量就是：你如何看待你自己的程序。找出一个缺乏 "间接层利益" 之处，在不修改现有行为的前提下，为它加入一个间接层。现在你获得了一个更有价值的程序，因为它有较高的质量，让我们在明天 (未来) 受益。
## 修改接口
当需要修改的接口被那些 "找不到，即使找到也不能修改" 的代码使用时，接口的修改就会成为问题。对于这种接口，我们可以称其为已发布接口 (pblished interface)。
简而言之，如果重构手法改变了已发布接口，你必须同时维护新旧两个接口，知道所有用户都有时间对这个变化做出反映。
## 何时不该重构
有时候你根本不应该重构，例如当你应该重新编写所有代码的时候。有时候既有代码是在太混乱，重构它还不如重新写一个来得简单。作出这种决定很困难，我承认我也没有什么好准则可以判断何时应该放弃重构。
重写 (而非重构) 的一个清除讯号就是：现有代码更笨不能正常运行。你可能只是试着做点测试，然后发现代码中满是错误，根本无法稳定运作。记住，重构之前，代码必须起码能够在大部分情况下正常运作。

一个折中办法就是：将 "大块头软件" 重构为封装良好的小型组件。然后你就可以逐一对组件做出 "重构或重建" 的决定。这是一个颇有希望的办法，但我还没有足够数据，所以也无法写出好的指导原则。对于一个重要的遗留系统，这肯定会是一个好的方向。
## 重构与设计

## 重构与性能
首先写出可调的软件，然后调整它以求获得足够速度。
和重构一样，你应该小幅度进行修改。每一步都需要编译、测试、再次度量。如果没有提高性能，就应该撤销此次修改。

## 代码坏味道
- Duplicated Code （重复代码)
- Long Method (过长函数)
- Large Class (过大的类)
- Divergent Change (发散式变化)
如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change 就出现了。针对某一外界变化的所有相应修改，都只应该发生在单一类中。为此，应该找出某特定原因而造成的所有变化，然后运用Extract Class (149) 将它们提炼到另一个类中。
- Shotgun Surgery (霰弹式修改)
Shotgun Surgery跟Divergent Change，恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是Shotgun Surgery。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。
这种情况应该使用Move Method 和 Move Field把所有需要修改的代码放进同一个类。
Divergent Change是指 "一个类受多种变化的影响"，Shotgun Surgery则是指 "一种变化引起多个类相应修改"。
- Feature Envy (依恋情节)
- Data Clumps (数据泥团)
- Primitive Obsession (基本类型偏执)
如果你有一组应该总是被放在一起的字段，可运用 Extract Class。如果你再参数列中看到基本型数据，不妨试试 Introduce Parameter Object。如果你发现自己正从数组中挑选数据，可运行Replace Array with Object。
- Switch Statements (switch惊悚现身)
大多数时候，一看到switch语句，你就应该考虑以多太来替换它。问题是多态该出现在哪儿？
- Parallel Inheritance Hierarchies (平行继承体系)
在这种情况下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。
消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用Move Method (142) 和 Move Field (146)，就可以将引用端的继承体系消弭于无形。
- Lazy Class (冗赘类)
如果这些子类没有足够的工作，试试Collapase (344)。对于几乎没有用的组件，你应该以Inline Class (154) 对付它们。
- Speculative Generality (夸夸其他未来性)
- Temporary Field (令人迷惑的暂时字段)
- Message Chains (过度耦合的消息链)
通过把调用链隐藏到直接调用者里面，减少代码耦合度，因为调用者并不关心调用链内部是如何调用的，而是想直接获得结果。
- Middle Man (中间人)
人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用Remove Middle Man，直接和真正负责的对象打交道。如果这样 "不干实事"的函数只有少数几个，可以运用InlineMethod (117) 把它们放进调用端。如果这些Middle Man还有其他行为，可以运用Replace Delegation with Inheritance (355) 把它编程实责对象的子类。
- Inappropriate Intimacy (狎昵关系)
- Alternative Classes with Different Interfaces (异曲同工的类)
- Incomplete Library Class (不完美的库类)
如果你只想修改库类的一两个函数，可以运用Introduce Foreign Method (162)；如果想要添加一大堆额外行为，就得运用Introduce Local Extension (164).
- Data Class (纯稚的数据类)
- Refused Bequest (被拒绝的遗赠)
如果有些方法或者字段，属于不同的实现类细节，需要运用Push Down Method (328) 和 Push Down Field (329) 把所有用不到的函数下推给用得到的兄弟类中，从而当前子类不用继承这些多余的字段和函数。
- Comments (过多的注释)

## 重构的记录格式
首先是名称 (name)。
名称之后是一个简短概要 (summary)。
动机 (motivation) 为你介绍 "为什么需要这个重构" 和 "什么情况下不该使用这个重构"。
做法 (mechanics)
范例 (examples)

# 第6章 重新组织函数
## Remove Assignments to Parameters  (移除对参数的赋值)
## Replace Method with Method Object (以函数对象取代函数)
重构前：
```java
	Class Accountint

	gamma(int inputVal, int quantity, int yearToDate) {
		int importantValue1 = (inputVal * quantity) + delta();
		int importantValue2 = (inputVal * yearToDate) + 100;
		if ((yearToDate - importantValue1) > 100) {
			importantValue2 -= 20;
		}
		int importantValue3 = importantValue2 * 7;
				// and so on.
		return importantValue3 - 2 * importantValue1;
		}
	}

```
重构后：
```java
class Gamma...
private final Account _account;
private int inputVal;
private int quantity;
private int yearToDate;
private int importantValue1;
private int importantValue2;
private int importantValue3
...
Gamma (Account source,int inputValArg,int quantityArg,int yearToDateArg){_account = source;inputVal = inputValArg;quantity = quantityArg;yearToDate = yearToDateArg;}

	int compute() {
		importantValue1 = (inputVal * quantity) + _account.delta();
		importantValue2 = (inputVal * yearToDate) + 100;
		if ((yearToDate - importantValue1) > 100) {
			importantValue2 -= 20;
		}
		int importantValue3 =
				importantValue2 * 7;
		// and so on.
		 return importantValue3 - 2 * importantValue1;
	}

```
这个时候，我们可以对新类中的compute方法进行任意的Extract Method方法来进行重构，而不会被过的临时变量所羁绊了。
原方法的工作我们改为委托给刚完成的这个函数对象：
```java
int gamma (int inputVal,int quantity,int yearToDate){return new Gamma(this,inputVal,quantity,yearToDate).compute();}
```
## Substitute Algorithm (替换算法)
随着对问题有了更多理解，你往往会发现在原先的做法之外，有更简单的解决方案，此时你就需要改变原先的算法。如果开始使用程序库，而其中提供的某些功能/特性与你自己的代码重复，那么你也需要改变原先的算法。

# 第7章 在对象之间搬移特性
## Move Method (搬移函数)
## Move Field (搬移字段)
在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。
**在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。**
## Extract Class (提炼类)
某个类做了应该由两个类做的事。
**建立一个新类，将相关的字段和函数从旧类搬移到新类。**
## Inline Class (将类内联化)
某个类没有做太多事情。
**将这个类的所有特性搬移到另一个类中，然后移除原类。**
## Hide Delegate (隐藏 "委托关系")
客户通过一个委托类来调用另一个对象。
**在服务类上建立客户所需的所有函数，用以隐藏委托关系。**
## Remove Middle Man (移除中间人)
某个类做了过多的简单委托动作。
**让客户直接调用受委托类。**
```ad-note
Hide Delegate 和 Remove Middle Man 是互为逆过程
```
## Introduce Foreign Method (引入外加函数)
你需要为提供服务的类增加一个函数，但你无法修改这个类。
**在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。**
## Introduce Local Extension (引入本地扩展)
你需要为服务类提供一些额外函数，但你无法修改这个类。
**新建一个新类，使它包含这些额外函数。让这个扩展品称为源类的子类或包装类。**

## Self Encapsulate Field (自封装字段)
你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。
**为这个字段建立取值/设值函数，并且只以这些函数来访问字段。**
## Encapsulate Field (封装字段)
你的类中存在一个public字段。
**将它声明为private，并提供相应的访问函数。**
## Encapsulate Collection (封装集合)
有一个函数返回一个集合。
**让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。**
## Replace Record with Data Class (以数据类取代记录)
你需要面对传统编程环境中的记录结构。
**为该记录创建一个 "哑巴" 数据对象。**

## Replace Type Code with Class (以类取代类型码)
类之中有一个数值类型码，但它并不影响类的行为。
**以一个新的类替换该数值类型码。**
## Replace Type Code with Subclasses (以子类取代类型码)
你有一个不可变的类型码，它会影响类的行为。
**以子类取代这个类型码。**

但为了能够顺利进行那样的重构，首先应该讲类型码替换为可拥有多态行为的继承体系。